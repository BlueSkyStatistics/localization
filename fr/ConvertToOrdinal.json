{
  "title": "Convertir en facteur(s) ordonné(s)/ordinal",
  "navigation": "Vers facteur/ordinal ordonné",
  "trg": "Variables à convertir en facteur/ordinal ordonné",
  "help": {
    "title": "Convertir en facteur(s) ordonné(s)/ordinal",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>Description</b></br>\nLa fonction factor est utilisée pour créer une variable de facteur/ordinal ordonné. Les niveaux de facteur sont supposés être ordonnés. \n<br/>\n<b>Utilisation</b>\n<br/>\n<code>\nfactor(x = character(),  ordered = TRUE)\n</code> <br/>\n<b>Arguments</b><br/>\n<ul>\n<li>\nx: un vecteur de données, prenant généralement un petit nombre de valeurs distinctes.\n</li>\n<li>\nlevels:\tvecteur optionnel des valeurs (sous forme de chaînes de caractères) que x pourrait avoir prises. La valeur par défaut est l'ensemble unique de valeurs prises par as.character(x), triées dans l'ordre croissant de x. Notez que cet ensemble peut être spécifié comme étant plus petit que sort(unique(x)).\n</li>\n<li>\nlabels:\tvecteur de caractères optionnel pour les niveaux (dans le même ordre que levels après suppression de ceux dans exclude), ou une chaîne de caractères de longueur 1.\n</li>\n<li>\nexclude: Un vecteur de valeurs à exclure lors de la formation de l'ensemble des niveaux. Cela doit être du même type que x, et sera converti si nécessaire.\n</li>\n<li>\nordered: indicateur logique pour déterminer si les niveaux doivent être considérés comme ordonnés (dans l'ordre donné).\n</li>\n<li>\nnmax: une limite supérieure sur le nombre de niveaux ; voir 'Détails'.\n</li>\n<li>\n...(in ordered(.)): n'importe lequel des éléments ci-dessus, à l'exception de ordered lui-même.\n</li>\n<li>\nifany: (ajouter une niveau NA uniquement s'il est utilisé, c'est-à-dire si any(is.na(x)).\n</li>\n</ul>\n<b>Détails</b></br>\nLe type du vecteur x n'est pas restreint ; il doit simplement avoir une méthode as.character et être triable (par sort.list).<br/>\nLes facteurs ordonnés diffèrent des facteurs uniquement par leur classe, mais les méthodes et les fonctions d'ajustement de modèle traitent les deux classes de manière très différente.<br/>\nL'encodage du vecteur se fait comme suit. D'abord, toutes les valeurs dans exclude sont supprimées de levels. Si x[i] est égal à levels[j], alors le i-ème élément du résultat est j. Si aucune correspondance n'est trouvée pour x[i] dans levels (ce qui se produira pour les valeurs exclues), alors le i-ème élément du résultat est défini sur NA.<br/>\nNormalement, les 'levels' utilisés comme attribut du résultat sont l'ensemble réduit de niveaux après suppression de ceux dans exclude, mais cela peut être modifié en fournissant des labels. Cela devrait être soit un ensemble de nouvelles étiquettes pour les niveaux, soit une chaîne de caractères, auquel cas les niveaux sont cette chaîne de caractères avec un numéro de séquence ajouté.<br/>\nfactor(x, exclude = NULL) appliqué à un facteur est une opération nulle à moins qu'il n'y ait des niveaux inutilisés : dans ce cas, un facteur avec l'ensemble de niveaux réduit est retourné. Si exclude est utilisé, il doit également s'agir d'un facteur avec le même ensemble de niveaux que x ou un ensemble de codes pour les niveaux à exclure.<br/>\nLes codes d'un facteur peuvent contenir NA. Pour un x numérique, définissez exclude = NULL pour faire de NA un niveau supplémentaire (imprimé comme <NA>) ; par défaut, c'est le dernier niveau.<br/>\nSi NA est un niveau, la façon de définir un code comme manquant (par opposition au code du niveau manquant) est d'utiliser is.na sur le côté gauche d'une affectation (comme dans is.na(f)[i] <- TRUE ; l'indexation à l'intérieur de is.na ne fonctionne pas). Dans ces circonstances, les valeurs manquantes sont actuellement imprimées comme <NA>, c'est-à-dire identiques aux entrées du niveau NA.<br/>\nis.factor est générique : vous pouvez écrire des méthodes pour gérer des classes spécifiques d'objets, voir InternalMethods.<br/>\nLorsque levels n'est pas fourni, unique est appelé. Étant donné que les facteurs ont généralement un nombre relativement faible de niveaux, il est utile de fournir nmax comme limite supérieure pour le nombre de valeurs uniques.<br/>\n<b>Valeur</b><br/>\nfactor retourne un objet de classe \"factor\" qui a un ensemble de codes entiers de la longueur de x avec un attribut \"levels\" de mode caractère et unique (!anyDuplicated(.)) entrées. Si l'argument ordered est vrai (ou ordered() est utilisé), le résultat a la classe c(\"ordered\", \"factor\").<br/>\nAppliquer factor à un facteur ordonné ou non ordonné retourne un facteur (du même type) avec juste les niveaux qui se produisent : voir aussi [.factor pour une manière plus transparente d'y parvenir.\nis.factor retourne TRUE ou FALSE selon que son argument est de type facteur ou non. En conséquence, is.ordered retourne TRUE lorsque son argument est un facteur ordonné et FALSE sinon.<br/>\nas.factor convertit son argument en facteur. C'est une forme abrégée de factor.<br/>\nas.ordered(x) retourne x si cela est ordonné, et ordered(x) sinon.<br/>\naddNA modifie un facteur en transformant NA en un niveau supplémentaire (de sorte que les valeurs NA soient comptées dans les tableaux, par exemple).<br/>\n<b>Paquet</b></br>\nbase</br>\n<b>Aide</b></br>\nhelp(factor, package =base)\n"
  }
}