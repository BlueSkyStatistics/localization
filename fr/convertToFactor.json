{
  "title": "Convertir en facteur(s)",
  "navigation": "Vers facteur",
  "trg": "Variables à convertir en facteur",
  "help": {
    "title": "Convertir en facteur(s)",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>Description</b></br>\nLa fonction factor est utilisée pour encoder un vecteur en tant que facteur (les termes ‘catégorie’ et ‘type énuméré’ sont également utilisés pour les facteurs). Si l'argument ordered est TRUE, les niveaux du facteur sont supposés être ordonnés. Pour la compatibilité avec S, il existe également une fonction ordered.\nis.factor, is.ordered, as.factor et as.ordered sont les fonctions d'appartenance et de coercition pour ces classes.\n<br/>\n<b>Utilisation</b>\n<br/>\n<code>\nfactor(x = character(), levels, labels = levels,\n        exclude = NA, ordered = is.ordered(x), nmax = NA)\nordered(x, ...)\nis.factor(x)\nis.ordered(x)\nas.factor(x)\nas.ordered(x)\naddNA(x, ifany = FALSE)\n</code> <br/>\n<b>Arguments</b><br/>\n<ul>\n<li>\nx : un vecteur de données, prenant généralement un petit nombre de valeurs distinctes.\n</li>\n<li>\nlevels : un vecteur optionnel des valeurs (sous forme de chaînes de caractères) que x pourrait avoir prises. La valeur par défaut est l'ensemble unique de valeurs prises par as.character(x), triées dans l'ordre croissant de x. Notez que cet ensemble peut être spécifié comme étant plus petit que sort(unique(x)).\n</li>\n<li>\nlabels : soit un vecteur de caractères optionnel de labels pour les niveaux (dans le même ordre que les niveaux après avoir retiré ceux dans exclude), soit une chaîne de caractères de longueur 1.\n</li>\n<li>\nexclude : un vecteur de valeurs à exclure lors de la formation de l'ensemble des niveaux. Cela doit être du même type que x, et sera coercé si nécessaire.\n</li>\n<li>\nordered : un indicateur logique pour déterminer si les niveaux doivent être considérés comme ordonnés (dans l'ordre donné).\n</li>\n<li>\nnmax : une limite supérieure sur le nombre de niveaux ; voir ‘Détails’.\n</li>\n<li>\n...(dans ordered(.)) : n'importe lequel des éléments ci-dessus, à l'exception de ordered lui-même.\n</li>\n<li>\nifany : (ajouter un niveau NA uniquement s'il est utilisé, c'est-à-dire si any(is.na(x)).\n</li>\n</ul>\n<b>Détails</b></br>\nLe type du vecteur x n'est pas restreint ; il doit seulement avoir une méthode as.character et être triable (par sort.list).<br/>\nLes facteurs ordonnés diffèrent des facteurs uniquement par leur classe, mais les méthodes et les fonctions d'ajustement de modèle traitent les deux classes de manière assez différente.<br/>\nL'encodage du vecteur se fait comme suit. D'abord, toutes les valeurs dans exclude sont retirées des niveaux. Si x[i] est égal à levels[j], alors l'élément i du résultat est j. Si aucune correspondance n'est trouvée pour x[i] dans levels (ce qui se produira pour les valeurs exclues), alors l'élément i du résultat est défini sur NA.<br/>\nNormalement, les ‘niveaux’ utilisés comme attribut du résultat sont l'ensemble réduit de niveaux après avoir retiré ceux dans exclude, mais cela peut être modifié en fournissant des labels. Cela devrait être soit un ensemble de nouveaux labels pour les niveaux, soit une chaîne de caractères, auquel cas les niveaux sont cette chaîne de caractères avec un numéro de séquence ajouté.<br/>\nfactor(x, exclude = NULL) appliqué à un facteur est une opération nulle à moins qu'il n'y ait des niveaux inutilisés : dans ce cas, un facteur avec l'ensemble de niveaux réduit est retourné. Si exclude est utilisé, il doit également s'agir d'un facteur avec le même ensemble de niveaux que x ou d'un ensemble de codes pour les niveaux à exclure.<br/>\nLes codes d'un facteur peuvent contenir NA. Pour un x numérique, définissez exclude = NULL pour faire de NA un niveau supplémentaire (s'affiche comme <NA>) ; par défaut, c'est le dernier niveau.<br/>\nSi NA est un niveau, la façon de définir un code comme manquant (par opposition au code du niveau manquant) est d'utiliser is.na sur le côté gauche d'une affectation (comme dans is.na(f)[i] <- TRUE ; l'indexation à l'intérieur de is.na ne fonctionne pas). Dans ces circonstances, les valeurs manquantes sont actuellement imprimées comme <NA>, c'est-à-dire identiques aux entrées du niveau NA.<br/>\nis.factor est générique : vous pouvez écrire des méthodes pour gérer des classes spécifiques d'objets, voir InternalMethods.<br/>\nLorsque levels n'est pas fourni, unique est appelé. Étant donné que les facteurs ont généralement un nombre assez réduit de niveaux, pour de grands vecteurs x, il est utile de fournir nmax comme limite supérieure sur le nombre de valeurs uniques.<br/>\n<b>Valeur</b><br/>\nfactor retourne un objet de classe \"facteur\" qui a un ensemble de codes entiers de la longueur de x avec un attribut \"niveaux\" de mode caractère et unique (!anyDuplicated(.)) entrées. Si l'argument ordered est vrai (ou ordered() est utilisé), le résultat a la classe c(\"ordonné\", \"facteur\").<br/>\nAppliquer factor à un facteur ordonné ou non ordonné retourne un facteur (du même type) avec juste les niveaux qui se produisent : voir aussi [.factor pour une manière plus transparente d'y parvenir.\nis.factor retourne TRUE ou FALSE selon que son argument est de type facteur ou non. En conséquence, is.ordered retourne TRUE lorsque son argument est un facteur ordonné et FALSE sinon.<br/>\nas.factor contraint son argument à un facteur. C'est une forme abrégée de factor.<br/>\nas.ordered(x) retourne x si cela est ordonné, et ordered(x) sinon.<br/>\naddNA modifie un facteur en transformant NA en un niveau supplémentaire (afin que les valeurs NA soient comptées dans les tableaux, par exemple).<br/>\n<b>Package</b></br>\nbase</br>\n<b>Aide</b></br>\nhelp(factor, package =fastDummies)\n"
  }
}