{
  "title": "Régression Ordinale",
  "navigation": "Ordinal",
  "label1": "Méthode de test",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Entrez le nom du modèle",
  "dependent": "Variable dépendante",
  "formula": "Variable(s) indépendante(s)",
  "generateplotchk": "Tracer les résidus vs ajustés, Q-Q normal, échelle-localisation et résidus vs levier",
  "weights": "Spécifiez une variable avec des poids",
  "help": {
    "title": "Ordinal",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Description</b></br>\n            Ajuste un modèle de régression logistique ou probit à une réponse de facteur ordonné. Le cas logistique par défaut est la régression logistique des cotes proportionnelles, d'où le nom de la fonction.\n            <br/>\n            <b>Utilisation</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Arguments</b><br/>\n            <ul>\n            <li>\n            formula: une expression de formule comme pour les modèles de régression, de la forme réponse ~ prédicteurs. La réponse doit être un facteur (de préférence un facteur ordonné), qui sera interprété comme une réponse ordinale, avec des niveaux ordonnés comme dans le facteur. Le modèle doit avoir une intercept : les tentatives de suppression d'une entraîneront un avertissement et seront ignorées. Un offset peut être utilisé. Voir la documentation de la formule pour d'autres détails.\n            </li>\n            <li>\n            data: un cadre de données optionnel dans lequel interpréter les variables apparaissant dans la formule.\n            </li>\n            <li>\n            weights: poids de cas optionnels lors de l'ajustement. Par défaut à 1.\n            </li>\n            <li>\n            start: valeurs initiales pour les paramètres. Ceci est au format c(coefficients, zeta): voir la section Valeurs.\n            </li>\n            <li>\n            ... arguments supplémentaires à passer à optim, le plus souvent un argument de contrôle.\n            </li>\n            <li>\n            subset: expression indiquant quel sous-ensemble des lignes des données doit être utilisé dans l'ajustement. Toutes les observations sont incluses par défaut.\n            </li>\n            <li>\n            na.action: une fonction pour filtrer les données manquantes.\n            </li>\n            <li>\n            contrasts: une liste de contrastes à utiliser pour certains ou tous les facteurs apparaissant comme variables dans la formule du modèle.\n            </li>\n            <li>\n            Hess: logique pour savoir si le Hessien (la matrice d'information observée) doit être retourné. Utilisez ceci si vous avez l'intention d'appeler summary ou vcov sur l'ajustement.\n            </li>\n            <li>\n            model: logique pour savoir si la matrice du modèle doit être retournée.\n            </li>\n            <li>\n            method: logistique ou probit ou (complémentaire) log-log ou cauchit (correspondant à une variable latente de Cauchy).\n            </li>\n            </ul>\n            <b>Détails</b></br>\n            Ce modèle est ce qu'Agresti (2002) appelle un modèle de lien cumulatif. L'interprétation de base est celle d'une version grossière d'une variable latente Y_i qui a une distribution logistique ou normale ou de valeur extrême ou de Cauchy avec un paramètre d'échelle un et un modèle linéaire pour la moyenne. Le facteur ordonné qui est observé est dans quel bin Y_i tombe avec des points de rupture\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Cela conduit au modèle</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            avec logit remplacé par probit pour une variable latente normale, et eta étant le prédicteur linéaire, une fonction linéaire des variables explicatives (sans intercept). Notez qu'il est assez courant pour d'autres logiciels d'utiliser le signe opposé pour eta (et donc les coefficients beta).</br>\n            Dans le cas logistique, le côté gauche de la dernière affiche est les cotes logarithmiques de la catégorie k ou moins, et puisque ce sont des cotes logarithmiques qui diffèrent seulement par une constante pour différents k, les cotes sont proportionnelles. D'où le terme régression logistique des cotes proportionnelles.</br>\n            Les liens log-log et log-log complémentaires sont les fonctions croissantes F^-1(p) = -log(-log(p)) et F^-1(p) = log(-log(1-p)); certains appellent le premier le lien « log-log négatif ». Ceux-ci correspondent à une variable latente avec la distribution de valeur extrême pour le maximum et le minimum respectivement.</br>\n            Un modèle de risques proportionnels pour les temps de survie groupés peut être obtenu en utilisant le lien log-log complémentaire avec un groupement ordonné par des temps croissants.</br>\n            predict, summary, vcov, anova, model.frame et une méthode extractAIC pour une utilisation avec stepAIC (et step). Il existe également des méthodes de profil et de confint.</br>\n            <b>Valeur</b><br/>\n            Un objet de classe \"polr\". Cela a des composants\n            <li>\n            coefficients: les coefficients du prédicteur linéaire, qui n'a pas d'intercept.\n            </li>\n            <li>\n            zeta: les intercepts pour les frontières de classe.\n            </li>\n            <li>\n            deviance: la déviance résiduelle.\n            </li>\n            <li>\n            fitted.values: une matrice, avec une colonne pour chaque niveau de la réponse.\n            </li>\n            <li>\n            lev: les noms des niveaux de réponse.\n            </li>\n            <li>\n            terms: la structure des termes décrivant le modèle.\n            </li>\n            <li>\n            df.residual: le nombre de degrés de liberté résiduels, calculé en utilisant les poids.\n            </li>\n            <li>\n            edf: le nombre (effectif) de degrés de liberté utilisés par le modèle\n            </li>\n            <li>\n            n, nobs: le nombre (effectif) d'observations, calculé en utilisant les poids. (nobs est à utiliser par stepAIC.\n            </li>\n            <li>\n            call: l'appel correspondant.\n            </li>\n            <li>\n            method: la méthode correspondante utilisée.\n            </li>\n            <li>\n            convergence: le code de convergence retourné par optim.\n            </li>\n            <li>\n            niter: le nombre d'évaluations de fonction et de gradient utilisées par optim.\n            </li>\n            <li>\n            lp: le prédicteur linéaire (y compris tout offset).</li>\n            <li>\n            Hessian: (si Hess est vrai). Notez qu'il s'agit d'une approximation numérique dérivée du processus d'optimisation.\n            </li>\n            <li>\n            model:(si le modèle est vrai).\n            </li>\n            <li>\n            Note</br>\n            La méthode vcov utilise le Hessien approximatif : pour des résultats fiables, la matrice du modèle doit être sensiblement mise à l'échelle avec toutes les colonnes ayant une plage de l'ordre de un.</br>\n            Avant la version 7.3-32, la méthode = \"cloglog\" donnait de manière confuse le lien log-log, supposant implicitement que le premier niveau de réponse était le « meilleur ».</br>\n            <br/>\n            <b>Exemples</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## ajustement légèrement moins bon de<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## bien qu'il ne soit pas vraiment approprié, peut ajuster<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Package</b></br>\n            MASS</br>\n            <b>Aide</b></br>\n            Pour une aide détaillée, cliquez sur l'icône R en haut à droite de cette superposition de dialogue ou exécutez la commande suivante help(polr, package =MASS) en créant un bloc de code R en cliquant + dans la fenêtre de sortie\t\t\t"
  }
}