{
  "title": "方差分析与似然比检验",
  "navigation": "方差分析与似然比",
  "label1": "方差分析适用于以下类别的模型（括号内为R类）线性模型（lm），广义线性模型（glm），负二项对数线性模型（negbin），使用广义最小二乘法的线性模型（gls），生存回归模型（survreg），比例风险模型（coxph），Loess回归（loess）",
  "label2": "**注意：对于通过模型调优（类train）创建的模型，不支持似然检验，",
  "modelselector1": "选择模型",
  "help": {
    "title": "方差分析与似然比检验",
    "r_help": "help(anova,package='stats')",
    "body": "\n                <b>描述</b></br>\n方差分析表：计算方差分析表并对拟合模型对象执行似然比检验。对于混合效应模型，随机效应的类似方差分析表将被显示。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nanova(object, ...)\n</code> <br/>\n<b>参数</b><br/>\n<ul>\n<li>\nobject: 包含模型拟合函数（例如lm或glm）返回结果的对象。\n</li>\n</ul>\n<b>值</b><br/>\n此（通用）函数返回一个anova类的对象。这些对象表示方差分析和偏差分析表。当给定单个参数时，它生成一个表，测试模型项是否显著。当给定一系列对象时，anova按指定顺序测试模型之间的关系。<br/>\nanova对象的打印方法以“美观”的形式打印表格。<br/>\n<b>警告</b><br/>\n两个或多个模型之间的比较仅在它们拟合于相同数据集时有效。如果存在缺失值并且使用R的默认na.action = na.omit，则可能会出现问题。<br/>\n<b>包</b></br>\nstats</br>\n<b>帮助</b></br>\n有关详细帮助，请单击此对话框覆盖右上角的R图标，或在R语法编辑器中运行以下命令help(anova,package='stats')</br></br>\n<b>描述</b></br>\n嵌套模型的似然比检验：lrtest是一个通用函数，用于执行似然比检验。默认方法可用于比较嵌套（广义）线性模型（见下文详细信息）。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nlrtest(object, ...)<br/>\n## 默认S3方法：<br/>\nlrtest(object, ..., name = NULL) <br/>\n## 类'formula'的S3方法<br/>\nlrtest(object, ..., data = list())<br/>\n</code> <br/>\n<b>参数</b><br/>\n<ul>\n<li>\nobject: 一个对象。有关详细信息，请参见下文。\n</li>\n<li>\n...: 传递给方法的进一步对象规格。有关详细信息，请参见下文。\n</li>\n<li>\nname: 从拟合模型对象中提取合适名称/描述的函数。默认情况下，通过调用公式查询名称。\n</li>\n<li>\ndata: 包含模型中变量的数据框。\n</li>\n</ul>\n<b>详细信息</b></br>\nlrtest旨在成为通过渐近似然比检验比较模型的通用函数。默认方法依次比较拟合模型对象与传递的模型。在...中传递拟合模型对象时，可以使用整数、字符（两者均用于应从先前模型中消除的项）、更新公式或拟合模型对象来指定。除了最后一种情况，假定存在更新方法。有关详细信息，请参见waldtest。<br/>\n随后，对每两个连续模型进行渐近似然比检验：两倍的对数似然差（由logLik方法得出）与卡方分布进行比较。<br/>\n“公式”方法首先拟合lm，然后调用默认方法。<br/>\n<b>值</b><br/>\n一个anova类的对象，包含对数似然、自由度、自由度差、似然比卡方统计量及相应的p值。\n<b>示例</b><br/>\n<code> \n## 使用Greene（1993）中的数据：<br/>\n## 加载数据并计算滞后<br/>\ndata(\"USDistLag\")<br/>\nusdl <- na.contiguous(cbind(USDistLag, lag(USDistLag, k = -1)))<br/>\ncolnames(usdl) <- c(\"con\", \"gnp\", \"con1\", \"gnp1\")<br/>\nfm1 <- lm(con ~ gnp + gnp1, data = usdl)<br/>\nfm2 <- lm(con ~ gnp + con1 + gnp1, data = usdl)<br/>\n## 各种等效的LR检验规格<br/>\nlrtest(fm2, fm1)<br/>\nlrtest(fm2, 2)<br/>\nlrtest(fm2, \"con1\")<br/>\nlrtest(fm2, . ~ . - con1)<br/>\n</code> <br/>\n<b>描述</b></br>\n随机效应的ANOVA类似表：计算一个ANOVA类似表，测试模型中的随机效应项。每个随机效应项被减少或移除，并且模型减少的似然比检验以类似于drop1的形式呈现。rand是ranova的别名。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nranova(model, reduce.terms = TRUE, ...)<br/>\nrand(model, reduce.terms = TRUE, ...)<br/>\n</code> <br/>\n<b>参数</b><br/>\n<ul>\n<li>\nmodel: 使用lmer()拟合的线性混合效应模型（继承自类lmerMod）。\n</li>\n<li>\nreduce.terms: 如果为TRUE（默认），则随机效应项被减少（如果可能）。如果为FALSE，则随机效应项仅被移除。\n</li>\n</ul>\n<b>详细信息</b></br>\n如果模型使用REML拟合，则检验为REML似然比检验。<br/>\n形式为(f1 + f2 | gr)的随机效应项被减少为形式为(f2 | gr)和(f1 | gr)的项，这些减少的模型与原始模型进行比较。如果reduce.terms为FALSE，则(f1 + f2 | gr)将被移除。<br/>\n形式为(f1 | gr)的随机效应项被减少为(1 | gr)（除非reduce.terms为FALSE）。<br/>\n形式为(1 | gr)的随机效应项不会被减少，而是简单地移除。<br/>\n形式为(0 + f1 | gr)或(-1 + f1 | gr)的随机效应项被减少（如果reduce.terms = TRUE）为(1 | gr)。<br/>\n形式为(1 | gr1/gr2)的随机效应项自动扩展为两个项：(1 | gr2:gr1)和(1 | gr1)，使用findbars。<br/>\n在此说明中，无论f1和f2是因子还是连续变量均无关紧要。<br/>\n<b>值</b><br/>\n一个ANOVA类似表，具有随机效应的单项删除，继承自anova类和数据框，包含以下列：</br>\nnpar: 模型参数的数量。</br>\nlogLik: 模型的对数似然。请注意，如果模型使用REML拟合，则这是REML-logLik。</br>\nAIC: 模型的AIC评估为-2*(logLik - npar)。越小越好。</br>\nLRT: 似然比检验统计量；对数似然的两倍差异，渐近地服从卡方分布。</br>\nDf: 似然比检验的自由度：模型参数数量的差异。</br>\nPr(>Chisq) :p值。</br>\n<b>警告</b></br>\n在某些情况下，可能会生成非嵌套模型的检验。例如，当(0 + poly(x, 2) | gr)被减少（默认）为(1 | gr)时。根据我们所知，非嵌套模型比较仅在统计上毫无意义的情况下生成（例如在此示例中，随机截距被抑制）。</br>\n注意：anova可用于比较两个模型，并且通常能够生成与ranova相同的检验。然而，这并不总是如此，如示例所示。</br>\n<b>示例</b><br/>\n<code> \n# 测试将(Days | Subject)减少为(1 | Subject)：<br/>\nfm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)<br/>\nranova(fm1) # 2 df检验<br/>\n# 此检验也可以通过anova()实现：<br/>\nfm2 <- lmer(Reaction ~ Days + (1|Subject), sleepstudy)<br/>\nanova(fm1, fm2, refit=FALSE)<br/>\n# 演示reduce.test参数：<br/>\n# 测试移除(Days | Subject)：<br/>\nranova(fm1, reduce.terms = FALSE) # 3 df检验<br/>\n# 在这种情况下似然比检验统计量为：<br/>\nfm3 <- lm(Reaction ~ Days, sleepstudy)<br/>\n2*c(logLik(fm1, REML=TRUE) - logLik(fm3, REML=TRUE)) # LRT<br/>\n# anova()并不总是能够执行与ranova()相同的检验，<br/>\n# 例如：<br/>\nanova(fm1, fm3, refit=FALSE) # 比较REML与ML，不应使用<br/>\nanova(fm1, fm3, refit=TRUE) # 是ML拟合的检验，而不是我们所寻求的<br/>\n# 还要注意，lmer拟合需要首先进行，而不是lm拟合：<br/>\n# anova(fm3, fm1) # 不起作用并给出错误<br/>\n# ranova()可能不会生成所有相关检验：<br/>\n# 对于以下模型，ranova()指示我们不应减少<br/>\n# (TVset | Assessor)：<br/>\nfm <- lmer(Coloursaturation ~ TVset * Picture + (TVset | Assessor), data=TVbo)<br/>\nranova(fm)<br/>\n# 然而，更合适的模型是：<br/>\nfm2 <- lmer(Coloursaturation ~ TVset * Picture + (1 | TVset:Assessor), data=TVbo)<br/>\nanova(fm, fm2, refit=FALSE)<br/>\n# fm和fm2对数据的拟合基本相同，但fm使用了5个参数更多。<br/>\n</code> <br/>\n<b>包</b></br>\nlmerTest</br>\n<b>帮助</b></br>\n有关详细帮助，请单击此对话框覆盖右上角的R图标，或在R语法编辑器中运行以下命令help(ranova, package ='lmerTest')\n                "
  }
}