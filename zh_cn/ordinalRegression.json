{
  "title": "序数回归",
  "navigation": "序数",
  "label1": "测试方法",
  "logit": "逻辑回归",
  "probit": "概率单位",
  "modelname": "输入模型名称",
  "dependent": "因变量",
  "formula": "自变量",
  "generateplotchk": "绘制残差与拟合、正态Q-Q、尺度-位置和残差与杠杆的图",
  "weights": "指定一个权重变量",
  "help": {
    "title": "序数",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>描述</b></br>\n            拟合一个逻辑或概率回归模型到一个有序因子响应。默认的逻辑情况是比例赔率逻辑回归，函数以此命名。\n            <br/>\n            <b>用法</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>参数</b><br/>\n            <ul>\n            <li>\n            formula: 一个公式表达式，形式为响应 ~ 预测变量。响应应为一个因子（最好是有序因子），将被解释为有序响应，其级别按因子的顺序排列。模型必须有一个截距：尝试去掉一个将导致警告并被忽略。可以使用偏移量。有关其他细节，请参见公式的文档。\n            </li>\n            <li>\n            data: 一个可选的数据框，用于解释公式中出现的变量。\n            </li>\n            <li>\n            weights: 拟合中的可选案例权重。默认为1。\n            </li>\n            <li>\n            start: 参数的初始值。格式为c(系数, zeta)：见值部分。\n            </li>\n            <li>\n            ... 其他参数传递给optim，通常是控制参数。\n            </li>\n            <li>\n            subset: 表达式说明应使用数据的哪一部分行进行拟合。默认情况下包括所有观察。\n            </li>\n            <li>\n            na.action: 用于过滤缺失数据的函数。\n            </li>\n            <li>\n            contrasts: 用于模型公式中作为变量出现的某些或所有因子的对比列表。\n            </li>\n            <li>\n            Hess: 逻辑值，指示是否应返回Hessian（观察信息矩阵）。如果您打算在拟合上调用summary或vcov，请使用此选项。\n            </li>\n            <li>\n            model: 逻辑值，指示是否应返回模型矩阵。\n            </li>\n            <li>\n            method: 逻辑或概率或（补充）对数-对数或cauchit（对应于Cauchy潜变量）。\n            </li>\n            </ul>\n            <b>细节</b></br>\n            该模型是Agresti（2002）所称的累积链接模型。基本解释是作为一个潜变量Y_i的粗略版本，该变量具有逻辑或正态或极值或Cauchy分布，尺度参数为1，并且均值的线性模型。观察到的有序因子是Y_i落入的哪个区间，断点为\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            这导致模型</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            对于正态潜变量，logit被probit替换，eta是线性预测器，是解释变量的线性函数（没有截距）。请注意，其他软件通常使用相反的符号表示eta（因此系数beta）。</br>\n            在逻辑情况下，最后显示的左侧是类别k或更少的对数赔率，由于这些是仅因常数而异的对数赔率，因此赔率是成比例的。因此，称为比例赔率逻辑回归。</br>\n            对数-对数和补充对数-对数链接是增加函数F^-1(p) = -log(-log(p))和F^-1(p) = log(-log(1-p)); 有些人称第一个为“负对数-对数”链接。这对应于具有极值分布的潜变量，分别用于最大值和最小值。</br>\n            通过使用补充对数-对数链接，可以获得分组生存时间的比例风险模型，分组按增加的时间排序。</br>\n            predict, summary, vcov, anova, model.frame和用于stepAIC（和step）的extractAIC方法。还有profile和confint方法。</br>\n            <b>值</b><br/>\n            一个\"polr\"类的对象。它具有以下组件\n            <li>\n            coefficients: 线性预测器的系数，没有截距。\n            </li>\n            <li>\n            zeta: 类边界的截距。\n            </li>\n            <li>\n            deviance: 残差偏差。\n            </li>\n            <li>\n            fitted.values: 一个矩阵，每个响应级别有一列。\n            </li>\n            <li>\n            lev: 响应级别的名称。\n            </li>\n            <li>\n            terms: 描述模型的术语结构。\n            </li>\n            <li>\n            df.residual: 使用权重计算的残差自由度数。\n            </li>\n            <li>\n            edf: 模型使用的（有效）自由度数\n            </li>\n            <li>\n            n, nobs: 使用权重计算的（有效）观察数。（nobs用于stepAIC。\n            </li>\n            <li>\n            call: 匹配的调用。\n            </li>\n            <li>\n            method: 使用的匹配方法。\n            </li>\n            <li>\n            convergence: optim返回的收敛代码。\n            </li>\n            <li>\n            niter: optim使用的函数和梯度评估的数量。\n            </li>\n            <li>\n            lp: 线性预测器（包括任何偏移量）。</li>\n            <li>\n            Hessian: （如果Hess为真）。请注意，这是从优化过程中得出的数值近似。\n            </li>\n            <li>\n            model:(如果模型为真)。\n            </li>\n            <li>\n            注意</br>\n            vcov方法使用近似Hessian：为了获得可靠的结果，模型矩阵应合理缩放，所有列的范围应为一个数量级。</br>\n            在版本7.3-32之前，method = \"cloglog\"令人困惑地给出了对数-对数链接，隐含假设第一个响应级别是“最佳”。</br>\n            <br/>\n            <b>示例</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## 稍微较差的拟合来自<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## 尽管这并不真正合适，可以拟合<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>包</b></br>\n            MASS</br>\n            <b>帮助</b></br>\n            要详细帮助，请单击此对话框覆盖右上角的R图标，或通过创建R代码块运行以下命令help(polr, package =MASS)点击输出窗口中的+"
  }
}