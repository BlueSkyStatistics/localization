{
  "title": "Entscheidungsbäume",
  "navigation": "Entscheidungsbäume",
  "TxtTreeName": "Geben Sie den Modellnamen ein",
  "TreeGenChkbox": "Nicht neu generieren, wenn der Baum bereits existiert",
  "dependent": "Abhängige Variable",
  "independent": "Unabhängige Variable(n)",
  "weights": "Umfragegewichte",
  "TxtMinSplit": "Mindestaufteilung",
  "minBucket": "Mindestbucket",
  "TxtCP": "Komplexitätsparameter",
  "maxDepth": "Maximale Tiefe",
  "PruneTreeChkbox": "Baum beschneiden",
  "rd0": "Nicht beschneiden",
  "rd1": "Optimalen Komplexitätsparameter verwenden",
  "rd2": "Komplexitätsparameter angeben",
  "TxtCPPrune": "Geben Sie den Komplexitätsparameter ein",
  "PlotCVChkbox": "Kreuzvalidierung plotten",
  "PlotRSQRChkbox": "R-Quadrat plotten",
  "help": {
    "title": "Entscheidungsbäume",
    "r_help": "hilfe(rpart, paket ='rpart')",
    "body": "\n                <b>Hinweis</b></br>\n                Abhängige Variablen können Faktor, ordinal, Zeichenfolge, logisch und numerisch sein</br>\n                Unabhängige Variablen können Faktor, ordinal, Zeichenfolge, logisch und numerisch sein</br></br>\n                <b>Beschreibung</b></br>\n                Passen Sie ein rekursives Partitionierungs- und Regressionsbaum-Modell an\n                <br/>\n                <b>Verwendung</b>\n                <br/>\n                <code> \n                rpart(formel, daten, gewichte, untermenge, na.aktion = na.rpart, methode,\n                      modell = FALSE, x = FALSE, y = TRUE, parms, kontrolle, kosten, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                formel: eine Formel mit einer Antwort, aber ohne Interaktionstermine. Wenn dies ein Datenrahmen ist, wird dieser als Modellrahmen verwendet (siehe model.frame).\n                </li>\n                <li>\n                daten: ein optionaler Datenrahmen, in dem die in der Formel genannten Variablen interpretiert werden.\n                </li>\n                <li>\n                gewichte: optionale Fallgewichte.\n                </li>\n                <li>\n                untermenge: optionale Ausdruck, der besagt, dass nur eine Teilmenge der Zeilen der Daten im Fit verwendet werden sollte.\n                </li>\n                <li>\n                na.aktion: die Standardaktion löscht alle Beobachtungen, für die y fehlt, behält jedoch diejenigen, bei denen eine oder mehrere Prädiktoren fehlen.\n                </li>\n                <li>\n                methode: eine von \"anova\", \"poisson\", \"class\" oder \"exp\". Wenn die Methode fehlt, versucht die Routine, eine intelligente Vermutung zu machen. Wenn y ein Überlebensobjekt ist, wird angenommen, dass methode = \"exp\" ist, wenn y 2 Spalten hat, wird angenommen, dass methode = \"poisson\" ist, wenn y ein Faktor ist, wird angenommen, dass methode = \"class\" ist, andernfalls wird angenommen, dass methode = \"anova\" ist. Es ist am klügsten, die Methode direkt anzugeben, insbesondere da in Zukunft möglicherweise weitere Kriterien zur Funktion hinzugefügt werden.\n                Alternativ kann die Methode eine Liste von Funktionen mit den Namen init, split und eval sein. Beispiele sind in der Datei 'tests/usersplits.R' in den Quellen und in den Vignetten 'Benutzerdefinierte Split-Funktionen' angegeben.\n                </li>\n                <li>\n                modell: wenn logisch: eine Kopie des Modellrahmens im Ergebnis behalten? Wenn der Eingabewert für das Modell ein Modellrahmen ist (wahrscheinlich von einem früheren Aufruf der rpart-Funktion), wird dieser Rahmen anstelle der Konstruktion neuer Daten verwendet.\n                </li>\n                <li>\n                x: eine Kopie der x-Matrix im Ergebnis behalten.\n                </li>\n                <li>\n                y: eine Kopie der abhängigen Variablen im Ergebnis behalten. Wenn fehlt und das Modell bereitgestellt wird, ist dies standardmäßig FALSE.\n                </li>\n                <li>\n                parms: optionale Parameter für die Splitting-Funktion.<br/>\n                Anova-Splitting hat keine Parameter.<br/>\n                Poisson-Splitting hat einen einzigen Parameter, den Variationskoeffizienten der vorherigen Verteilung der Raten. Der Standardwert ist 1.<br/>\n                Exponential-Splitting hat denselben Parameter wie Poisson.<br/>\n                Für die Klassifikationsaufteilung kann die Liste Folgendes enthalten: den Vektor der vorherigen Wahrscheinlichkeiten (Komponente vorher), die Verlustmatrix (Komponente Verlust) oder den Splitting-Index (Komponente Split). Die Priors müssen positiv sein und sich auf 1 summieren. Die Verlustmatrix muss Nullen auf der Diagonalen und positive Elemente außerhalb der Diagonalen haben. Der Splitting-Index kann gini oder information sein. Die Standard-Priors sind proportional zu den Datenanzahlen, die Verluste standardmäßig 1 und der Split standardmäßig gini.<br/>\n                </li>\n                <li>\n                kontrolle: eine Liste von Optionen, die Details des rpart-Algorithmus steuern. Siehe rpart.control.\n                </li>\n                <li>\n                kosten: ein Vektor von nicht-negativen Kosten, einer für jede Variable im Modell. Standardmäßig eins für alle Variablen. Dies sind Skalierungen, die angewendet werden, wenn Splits in Betracht gezogen werden, sodass die Verbesserung beim Splitten einer Variablen durch ihre Kosten geteilt wird, um zu entscheiden, welchen Split zu wählen.\n                </li>\n                <li>\n                ...: Argumente zu rpart.control können auch im Aufruf zu rpart angegeben werden. Sie werden mit der Liste der gültigen Argumente überprüft.\n                </li>\n                </ul>\n                <b>Details</b></br>\n                Dies unterscheidet sich hauptsächlich in der Handhabung von Surrogatvariablen von der Baumfunktion in S. In den meisten Details folgt es Breiman et. al (1984) ziemlich genau. Das R-Paket tree bietet eine Neuimplementierung des Baums.\n                <b>Wert</b></br>\n                Ein Objekt der Klasse rpart. Siehe rpart.object.</br>\n                <b>Referenzen</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., und Stone, C. J. (1984) Klassifikation und Regressionsbäume. Wadsworth.</br>\n                <b>Siehe auch</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Beispiele</b></br>\n                fit <- rpart(Kyphosis ~ Alter + Anzahl + Start, daten = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Alter + Anzahl + Start, daten = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Alter + Anzahl + Start, daten = kyphosis,\n                              kontrolle = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # sonst wird der Text auf einigen Geräten abgeschnitten</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Paket</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Hilfe</b></br>\n                hilfe(rpart, paket ='rpart')</br></br>\n                <b>Beschreibung</b></br>\n                Steuerung für Rpart Fits. Verschiedene Parameter, die Aspekte der rpart-Anpassung steuern.\n                <br/>\n                <b>Verwendung</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                minsplit: die Mindestanzahl von Beobachtungen, die in einem Knoten vorhanden sein müssen, damit ein Split versucht werden kann.\n                </li>\n                <li>\n                minbucket: die Mindestanzahl von Beobachtungen in einem terminalen <leaf> Knoten. Wenn nur einer von minbucket oder minsplit angegeben ist, setzt der Code entweder minsplit auf minbucket*3 oder minbucket auf minsplit/3, je nach Bedarf.\n                </li>\n                <li>\n                cp: Komplexitätsparameter. Jeder Split, der die Gesamtanpassung nicht um einen Faktor von cp verringert, wird nicht versucht. Beispielsweise bedeutet dies bei Anova-Splitting, dass das gesamte R-Quadrat bei jedem Schritt um cp steigen muss. Die Hauptaufgabe dieses Parameters besteht darin, Rechenzeit zu sparen, indem Splits, die offensichtlich nicht lohnenswert sind, beschnitten werden. Im Wesentlichen informiert der Benutzer das Programm, dass jeder Split, der die Anpassung um cp nicht verbessert, wahrscheinlich durch Kreuzvalidierung beschnitten wird, und dass das Programm daher nicht weiterverfolgt werden muss.\n                </li>\n                <li>\n                maxcompete: die Anzahl der Wettbewerbs-Splits, die im Output beibehalten werden. Es ist nützlich zu wissen, welcher Split gewählt wurde, aber auch, welche Variable den zweiten, dritten usw. Platz belegt hat.\n                </li>\n                <li>\n                maxsurrogate: die Anzahl der Surrogat-Splits, die im Output beibehalten werden. Wenn dies auf null gesetzt ist, wird die Rechenzeit reduziert, da ungefähr die Hälfte der Rechenzeit (außer der Einrichtung) für die Suche nach Surrogat-Splits verwendet wird.\n                </li>\n                <li>\n                usesurrogate: wie Surrogates im Splitting-Prozess verwendet werden. 0 bedeutet nur anzeigen; eine Beobachtung mit einem fehlenden Wert für die primäre Split-Regel wird nicht weiter unten im Baum gesendet. 1 bedeutet, Surrogates in der Reihenfolge zu verwenden, um Subjekte zu splitten, die die primäre Variable vermissen; wenn alle Surrogates fehlen, wird die Beobachtung nicht gesplittet. Für den Wert 2, wenn alle Surrogates fehlen, wird die Beobachtung in die Mehrheit gerichtet. Ein Wert von 0 entspricht der Aktion des Baums, und 2 den Empfehlungen von Breiman et.al (1984).\n                </li>\n                <li>\n                xval: Anzahl der Kreuzvalidierungen.\n                </li>\n                <li>\n                surrogatestyle: steuert die Auswahl eines besten Surrogats. Wenn auf 0 (Standard) gesetzt, verwendet das Programm die Gesamtzahl der korrekten Klassifikationen für eine potenzielle Surrogatvariable, wenn auf 1 gesetzt, verwendet es den Prozentsatz der korrekten, berechnet über die nicht fehlenden Werte des Surrogats. Die erste Option bestraft Kovariaten mit einer großen Anzahl fehlender Werte strenger.\n                </li>\n                <li>\n                maxdepth: Setzen Sie die maximale Tiefe eines Knotens des endgültigen Baums, wobei der Wurzelknoten als Tiefe 0 gezählt wird. Werte größer als 30 geben auf 32-Bit-Maschinen unsinnige Ergebnisse zurück.\n                </li>\n                <li>\n                ...: andere Argumente aufräumen.\n                </li>\n                </ul>\n                <b>Wert</b></br>\n                Eine Liste, die die Optionen enthält. \n                      "
  }
}