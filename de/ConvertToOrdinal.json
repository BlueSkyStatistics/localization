{
  "title": "In geordnete Faktoren/Ordinal umwandeln",
  "navigation": "Zu geordnetem Faktor/Ordinal",
  "trg": "Variablen, die in geordnete Faktoren/Ordinal umgewandelt werden sollen",
  "help": {
    "title": "In geordnete Faktoren/Ordinal umwandeln",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>Beschreibung</b></br>\nDie Funktion factor wird verwendet, um eine geordnete Faktor/Ordinalvariable zu erstellen. Die Faktorstufen werden als geordnet angenommen. \n<br/>\n<b>Verwendung</b>\n<br/>\n<code>\nfactor(x = character(),  ordered = TRUE)\n</code> <br/>\n<b>Argumente</b><br/>\n<ul>\n<li>\nx: ein Vektor von Daten, der normalerweise eine kleine Anzahl von unterschiedlichen Werten annimmt.\n</li>\n<li>\nlevels:\tEin optionaler Vektor der Werte (als Zeichenfolgen), die x angenommen haben könnte. Der Standardwert ist die einzigartige Menge von Werten, die durch as.character(x) angenommen werden, sortiert in aufsteigender Reihenfolge von x. Beachten Sie, dass diese Menge kleiner als sort(unique(x)) angegeben werden kann.\n</li>\n<li>\nlabels:\tEntweder ein optionaler Vektor von Zeichenfolgen für die Stufen (in derselben Reihenfolge wie levels nach dem Entfernen der in exclude), oder eine Zeichenfolge der Länge 1.\n</li>\n<li>\nexclude: Ein Vektor von Werten, die beim Bilden der Stufen ausgeschlossen werden sollen. Dies sollte vom selben Typ wie x sein und wird bei Bedarf umgewandelt.\n</li>\n<li>\nordered: logische Flagge, um zu bestimmen, ob die Stufen als geordnet betrachtet werden sollen (in der angegebenen Reihenfolge).\n</li>\n<li>\nnmax: eine obere Grenze für die Anzahl der Stufen; siehe 'Details'.\n</li>\n<li>\n...(in ordered(.)): alle oben genannten, außer ordered selbst.\n</li>\n<li>\nifany: (füge nur eine NA-Stufe hinzu, wenn sie verwendet wird, d.h. wenn any(is.na(x)).\n</li>\n</ul>\n<b>Details</b></br>\nDer Typ des Vektors x ist nicht eingeschränkt; er muss nur eine as.character-Methode haben und sortierbar sein (durch sort.list).<br/>\nGeordnete Faktoren unterscheiden sich von Faktoren nur in ihrer Klasse, aber Methoden und die Modellanpassungsfunktionen behandeln die beiden Klassen ganz unterschiedlich.<br/>\nDie Kodierung des Vektors erfolgt wie folgt. Zuerst werden alle Werte in exclude von levels entfernt. Wenn x[i] gleich levels[j] ist, dann ist das i-te Element des Ergebnisses j. Wenn für x[i] kein Übereinstimmung in levels gefunden wird (was für ausgeschlossene Werte der Fall sein wird), wird das i-te Element des Ergebnisses auf NA gesetzt.<br/>\nNormalerweise sind die 'levels', die als Attribut des Ergebnisses verwendet werden, die reduzierte Menge von levels, nachdem die in exclude entfernt wurden, aber dies kann durch die Bereitstellung von labels geändert werden. Dies sollte entweder eine Menge neuer Labels für die Stufen sein oder eine Zeichenfolge, in diesem Fall sind die Stufen diese Zeichenfolge mit einer angehängten Sequenznummer.<br/>\nfactor(x, exclude = NULL), das auf einen Faktor angewendet wird, ist eine No-Operation, es sei denn, es gibt ungenutzte Stufen: in diesem Fall wird ein Faktor mit der reduzierten Stufenmenge zurückgegeben. Wenn exclude verwendet wird, sollte es auch ein Faktor mit derselben Stufenmenge wie x oder eine Menge von Codes für die auszuschließenden Stufen sein.<br/>\nDie Codes eines Faktors können NA enthalten. Für ein numerisches x setzen Sie exclude = NULL, um NA zu einer zusätzlichen Stufe zu machen (wird als <NA> gedruckt); standardmäßig ist dies die letzte Stufe.<br/>\nWenn NA eine Stufe ist, besteht der Weg, um einen Code als fehlend festzulegen (im Gegensatz zum Code der fehlenden Stufe), darin, is.na auf der linken Seite einer Zuweisung zu verwenden (wie in is.na(f)[i] <- TRUE; Indizierung innerhalb von is.na funktioniert nicht). Unter diesen Umständen werden fehlende Werte derzeit als <NA> gedruckt, d.h. identisch zu Einträgen der Stufe NA.<br/>\nis.factor ist generisch: Sie können Methoden schreiben, um spezifische Klassen von Objekten zu behandeln, siehe InternalMethods.<br/>\nWo levels nicht angegeben ist, wird unique aufgerufen. Da Faktoren typischerweise eine recht kleine Anzahl von Stufen haben, ist es hilfreich, nmax als obere Grenze für die Anzahl der einzigartigen Werte anzugeben.<br/>\n<b>Wert</b><br/>\nfactor gibt ein Objekt der Klasse \"factor\" zurück, das eine Menge von Ganzzahlcodes der Länge x mit einem \"levels\"-Attribut vom Modus Zeichenfolge und einzigartigen (!anyDuplicated(.)) Einträgen hat. Wenn das Argument ordered true ist (oder ordered() verwendet wird), hat das Ergebnis die Klasse c(\"ordered\", \"factor\").<br/>\nDie Anwendung von factor auf einen geordneten oder ungeordneten Faktor gibt einen Faktor (des gleichen Typs) mit nur den Stufen zurück, die auftreten: siehe auch [.factor für eine transparentere Möglichkeit, dies zu erreichen.\nis.factor gibt TRUE oder FALSE zurück, je nachdem, ob sein Argument vom Typ Faktor ist oder nicht. Entsprechend gibt is.ordered TRUE zurück, wenn sein Argument ein geordneter Faktor ist, und FALSE andernfalls.<br/>\nas.factor wandelt sein Argument in einen Faktor um. Es ist eine abgekürzte Form von factor.<br/>\nas.ordered(x) gibt x zurück, wenn dies geordnet ist, und ordered(x) andernfalls.<br/>\naddNA modifiziert einen Faktor, indem NA in eine zusätzliche Stufe umgewandelt wird (so dass NA-Werte in Tabellen gezählt werden, zum Beispiel).<br/>\n<b>Paket</b></br>\nbase</br>\n<b>Hilfe</b></br>\nhelp(factor, package =base)\n"
  }
}