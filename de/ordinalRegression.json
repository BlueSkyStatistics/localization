{
  "title": "Ordinale Regression",
  "navigation": "Ordinal",
  "label1": "Testmethode",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Modellnamen eingeben",
  "dependent": "Abhängige Variable",
  "formula": "Unabhängige Variable(n)",
  "generateplotchk": "Residuals vs. Fitted, Normal Q-Q, Scale-Location und Residuen vs. Leverage plotten",
  "weights": "Eine Variable mit Gewichten angeben",
  "help": {
    "title": "Ordinal",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Beschreibung</b></br>\n            Passt ein logistisches oder probit Regressionmodell an eine ordinale Faktorantwort an. Der Standardfall der Logistik ist die proportionale Odds-Logistische Regression, nach der die Funktion benannt ist.\n            <br/>\n            <b>Verwendung</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argumente</b><br/>\n            <ul>\n            <li>\n            formula: ein Formel-Ausdruck wie für Regressionsmodelle, in der Form Antwort ~ Prädiktoren. Die Antwort sollte ein Faktor (vorzugsweise ein ordinaler Faktor) sein, der als ordinale Antwort interpretiert wird, mit geordneten Ebenen wie im Faktor. Das Modell muss einen Schnittpunkt haben: Versuche, einen zu entfernen, führen zu einer Warnung und werden ignoriert. Ein Offset kann verwendet werden. Siehe die Dokumentation der Formel für weitere Details.\n            </li>\n            <li>\n            data: ein optionales Datenrahmen, in dem die in der Formel vorkommenden Variablen interpretiert werden.\n            </li>\n            <li>\n            weights: optionale Fallgewichte beim Anpassen. Standardmäßig 1.\n            </li>\n            <li>\n            start: Anfangswerte für die Parameter. Dies ist im Format c(Koeffizienten, zeta): siehe den Abschnitt Werte.\n            </li>\n            <li>\n            ... zusätzliche Argumente, die an optim übergeben werden, meist ein Steuerargument.\n            </li>\n            <li>\n            subset: Ausdruck, der angibt, welcher Teil der Zeilen der Daten im Fit verwendet werden soll. Alle Beobachtungen sind standardmäßig enthalten.\n            </li>\n            <li>\n            na.action: eine Funktion zur Filterung fehlender Daten.\n            </li>\n            <li>\n            contrasts: eine Liste von Kontrasten, die für einige oder alle Faktoren verwendet werden, die als Variablen in der Modellformel erscheinen.\n            </li>\n            <li>\n            Hess: logisch, ob die Hessian (die beobachtete Informationsmatrix) zurückgegeben werden soll. Verwenden Sie dies, wenn Sie beabsichtigen, Zusammenfassungen oder vcov auf den Fit anzuwenden.\n            </li>\n            <li>\n            model: logisch, ob die Modellmatrix zurückgegeben werden soll.\n            </li>\n            <li>\n            method: logistisch oder probit oder (komplementär) log-log oder cauchit (entsprechend einer Cauchy-latenten Variablen).\n            </li>\n            </ul>\n            <b>Details</b></br>\n            Dieses Modell ist das, was Agresti (2002) ein kumulatives Linkmodell nennt. Die grundlegende Interpretation ist als eine grob gefasste Version einer latenten Variablen Y_i, die eine logistische oder normale oder extremwertige oder Cauchy-Verteilung mit einem Skalierungsparameter von eins und einem linearen Modell für den Mittelwert hat. Der beobachtete ordinale Faktor ist, in welches Intervall Y_i fällt, mit den Grenzwerten\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Dies führt zu dem Modell</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            wobei logit durch probit für eine normale latente Variable ersetzt wird, und eta der lineare Prädiktor ist, eine lineare Funktion der erklärenden Variablen (ohne Schnittpunkt). Beachten Sie, dass es ziemlich häufig ist, dass andere Software das entgegengesetzte Vorzeichen für eta (und damit die Koeffizienten beta) verwendet.</br>\n            Im logistischen Fall ist die linke Seite der letzten Anzeige die Log-Odds der Kategorie k oder weniger, und da dies Log-Odds sind, die sich nur durch eine Konstante für verschiedene k unterscheiden, sind die Odds proportional. Daher der Begriff proportionale Odds-logistische Regression.</br>\n            Die log-log und komplementären log-log Links sind die monotonen Funktionen F^-1(p) = -log(-log(p)) und F^-1(p) = log(-log(1-p)); einige nennen den ersten den ‘negativen log-log’ Link. Diese entsprechen einer latenten Variablen mit der extremwertigen Verteilung für das Maximum und Minimum.\n            Ein proportionaler Hazard-Modell für gruppierte Überlebenszeiten kann erhalten werden, indem der komplementäre log-log Link mit der Gruppierung nach zunehmenden Zeiten verwendet wird.</br>\n            predict, summary, vcov, anova, model.frame und eine extractAIC-Methode zur Verwendung mit stepAIC (und step). Es gibt auch Profil- und confint-Methoden.</br>\n            <b>Wert</b><br/>\n            Ein Objekt der Klasse \"polr\". Dies hat Komponenten\n            <li>\n            coefficients: die Koeffizienten des linearen Prädiktors, der keinen Schnittpunkt hat.\n            </li>\n            <li>\n            zeta: die Schnittpunkte für die Klassen-Grenzen.\n            </li>\n            <li>\n            deviance: die Residualdeviance.\n            </li>\n            <li>\n            fitted.values: eine Matrix, mit einer Spalte für jede Ebene der Antwort.\n            </li>\n            <li>\n            lev: die Namen der Antwort-Ebenen.\n            </li>\n            <li>\n            terms: die Struktur der Begriffe, die das Modell beschreibt.\n            </li>\n            <li>\n            df.residual: die Anzahl der Residualfreiheitsgrade, berechnet unter Verwendung der Gewichte.\n            </li>\n            <li>\n            edf: die (effektive) Anzahl der Freiheitsgrade, die vom Modell verwendet werden\n            </li>\n            <li>\n            n, nobs: die (effektive) Anzahl der Beobachtungen, berechnet unter Verwendung der Gewichte. (nobs ist zur Verwendung durch stepAIC).\n            </li>\n            <li>\n            call: der übereinstimmende Aufruf.\n            </li>\n            <li>\n            method: die übereinstimmende Methode, die verwendet wurde.\n            </li>\n            <li>\n            convergence: der Konvergenzcode, der von optim zurückgegeben wird.\n            </li>\n            <li>\n            niter: die Anzahl der Funktions- und Gradientenbewertungen, die von optim verwendet wurden.\n            </li>\n            <li>\n            lp: der lineare Prädiktor (einschließlich eines Offsets).</li>\n            <li>\n            Hessian: (wenn Hess wahr ist). Beachten Sie, dass dies eine numerische Näherung ist, die aus dem Optimierungsprozess abgeleitet wurde.\n            </li>\n            <li>\n            model:(wenn model wahr ist).\n            </li>\n            <li>\n            Hinweis</br>\n            Die vcov-Methode verwendet die ungefähre Hessian: für zuverlässige Ergebnisse sollte die Modellmatrix sinnvoll skaliert werden, wobei alle Spalten einen Bereich der Ordnung eins haben.</br>\n            Vor Version 7.3-32 gab die Methode = \"cloglog\" verwirrend den log-log Link zurück, wobei implizit angenommen wurde, dass die erste Antwort-Ebene die ‘beste’ war.</br>\n            <br/>\n            <b>Beispiele</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## leicht schlechtere Anpassung von<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## obwohl es nicht wirklich angemessen ist, kann angepasst werden<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Paket</b></br>\n            MASS</br>\n            <b>Hilfe</b></br>\n            Für detaillierte Hilfe klicken Sie auf das R-Symbol in der oberen rechten Ecke dieses Dialogüberlagerung oder führen Sie den folgenden Befehl aus help(polr, package =MASS), indem Sie einen R-Code-Chunk erstellen, indem Sie + im Ausgabefenster klicken\t\t\t"
  }
}