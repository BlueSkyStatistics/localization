{
  "title": "Corelație Polihorică",
  "navigation": "Polihoric",
  "Target": "Selectați una sau mai multe variabile x",
  "textbox1": "Interval de încredere",
  "textbox2": "Ipoteza nulă (mu)",
  "Target2": "Selectați o singură variabilă factor ordonată y",
  "label1": "Tipul de estimare",
  "test1": "Aproximare în două etape",
  "test2": "Estimare prin maxim-likelihood",
  "label2": "Eroare standard",
  "Missvals": "Afișați eroarea standard",
  "conflevel": "Corelație maximă absolută (pentru a asigura stabilitatea numerică).",
  "Seed": "Valoare de start opțională",
  "header": "Corelația este estimată între fiecare variabilă x și variabila y",
  "showEffectSizes": "Returnați pragurile estimate",
  "advanced_lbl" : "Avansat",
  "help": {
    "title": "Corelație Polihorică",
    "r_help": "help(polychor, package ='polycor')",
    "body": "\n<b>Descriere</b></br>\nCalculează corelația polihorică (și eroarea standard) între două variabile ordinale, sub presupunerea că variabilele ordinale disectează variabile latente continue care sunt bivariate normale. Fie estimarea prin maxim-likelihood, fie o aproximare (posibil mult) mai rapidă “two-step” este disponibilă. Pentru estimarea ML, estimările pragurilor și matricea de covarianță a estimărilor sunt de asemenea disponibile.\n<br/>\n<b>Utilizare</b>\n<br/>\n<code> \npolychor(x, y, ML = FALSE, control = list(), \n  std.err = FALSE, maxcor=.9999, start, thresholds=FALSE)\n</code> <br/>\n<b>Argumente</b><br/>\n<ul>\n<li>\nx: variabilă categorială ordonată; variabila poate fi numerică, logică, un factor, un factor ordonat sau o variabilă de tip caracter, dar dacă este un factor, nivelurile sale ar trebui să fie în ordinea corectă, iar valorile unei variabile de tip caracter sunt ordonate alfabetic.\n</li>\n<li>\ny: o variabilă factor ordonată\n</li>\n<li>\nML: dacă este TRUE, calculează estimarea prin maxim-likelihood; dacă este FALSE, implicit, calculează o aproximare mai rapidă “two-step”.\n</li>\n<li>\nstd.err: dacă este TRUE, returnează varianta estimată a corelației (pentru estimatorul în două etape) sau matricea de covarianță estimată (pentru estimatorul ML) a corelației și pragurilor; implicit este FALSE. \n</li>\n<li>\nmaxcor: corelație maximă absolută (pentru a asigura stabilitatea numerică).\n</li>\n<li>\nstart:  valoare de start opțională: dacă este un singur număr, valoare de start pentru corelație.\n</li>\n<li>\nthresholds:  dacă este TRUE (implicit este FALSE) returnează pragurile estimate împreună cu corelația estimată chiar dacă erorile standard nu sunt calculate.\n</li>\n</ul>\n<b>Valori</b></br>\nValoare: Dacă std.err sau thresholds este TRUE, returnează un obiect de clasă \"polycor\" cu următoarele componente:</br>\ntip: setat la \"polihoric\".</br>\nrho: corelația polihorică.</br>\nrow.cuts: pragurile estimate pentru variabila de rând (x), pentru estimarea ML.</br>\ncol.cuts: pragurile estimate pentru variabila de coloană (y), pentru estimarea ML.</br>\nvar: varianta estimată a corelației, sau, pentru estimarea ML, matricea de covarianță estimată a corelației și pragurilor.</br>\nn: numărul de observații pe care se bazează corelația.</br>\nchisq: test chi-pătrat pentru normalitatea bivariată.</br>\ndf: grade de libertate pentru testul de normalitate bivariată.</br>\nML: TRUE pentru estimarea ML, FALSE pentru estimarea în două etape\n<b>Detalii</b></br>\nEstimarea ML este calculată prin maximizarea verosimilității bivariate-normale în raport cu pragurile pentru cele două variabile (τ^x[i], i = 1,…, r - 1; τ^y[j], j = 1,…, c - 1) și corelația populației (ρ). Aici, r și c sunt respectiv numărul de niveluri ale x și y. Verosimilitatea este maximizată numeric folosind funcția optim, iar matricea de covarianță a parametrilor estimați se bazează pe Hessianul numeric calculat de optim.</br>\nEstimarea în două etape este calculată prin estimarea mai întâi a pragurilor (τ^x[i], i = 1,…, r - 1 și τ^y[j], i = j,…, c - 1) separat din distribuția marginală a fiecărei variabile. Apoi, verosimilitatea unidimensională pentru ρ este maximizată numeric, folosind optim dacă erorile standard sunt solicitate, sau optimise dacă nu sunt. Eroarea standard calculată tratează pragurile ca fiind fixe.\n<br/>\n<b>Exemplu</b></br>\n<code> \nif(require(mvtnorm)){\n    set.seed(12345)\n    data <- rmvnorm(1000, c(0, 0), matrix(c(1, .5, .5, 1), 2, 2))\n    x <- data[,1]\n    y <- data[,2]\n    cor(x, y)  # corelația de eșantion\n    }\n\nif(require(mvtnorm)){\n    x <- cut(x, c(-Inf, .75, Inf))\n    y <- cut(y, c(-Inf, -1, .5, 1.5, Inf))\n    polychor(x, y)  # estimare în 2 etape\n    }\n\nif(require(mvtnorm)){\n    polychor(x, y, ML=TRUE, std.err=TRUE)  # estimare ML\n    }\n</code> <br/>\n<b>Pachet</b></br>\npolycor</br>\n<b>Ajutor</b></br>\nPentru ajutor detaliat, faceți clic pe pictograma R din colțul din dreapta sus al acestui overlay de dialog sau rulați următoarea comandă help(polycor, package ='polychor') creând un chunk de cod R făcând clic pe + în fereastra de ieșire           \n    "
  }
}