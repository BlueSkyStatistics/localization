{
  "title": "Arbori de Decizie",
  "navigation": "Arbori de Decizie",
  "TxtTreeName": "Introduceți numele modelului",
  "TreeGenChkbox": "Nu regenerați dacă arborele există deja",
  "dependent": "Variabilă dependentă",
  "independent": "Variabilă(variabile) independent(e)",
  "weights": "Greutăți de sondaj",
  "TxtMinSplit": "Împărțire minimă",
  "minBucket": "Bucket minim",
  "TxtCP": "Parametru de complexitate",
  "maxDepth": "Adâncime maximă",
  "PruneTreeChkbox": "Rădăcina arborelui",
  "rd0": "Nu rădăcinați",
  "rd1": "Utilizați parametrul de complexitate optim",
  "rd2": "Specificați parametrul de complexitate",
  "TxtCPPrune": "Introduceți parametrul de complexitate",
  "PlotCVChkbox": "Trasați validarea încrucișată",
  "PlotRSQRChkbox": "Trasați R-pătratul",
  "OptvarPlots": "Grafice",
  "OptvarPreprune": "Pre-tăiere",
  "OptvarPrune": "Tăierea copacului",  
  "help": {
    "title": "Arbori de Decizie",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>Notă</b></br>\n                Variabilele dependente pot fi factor, ordinal, șir, logic și numeric</br>\n                Variabilele independente pot fi factor, ordinal, șir, logic și numeric</br></br>\n                <b>Descriere</b></br>\n                Se potrivește un model de Arbori de Partitionare Recursivă și Regresie\n                <br/>\n                <b>Utilizare</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                formula: o formulă, cu un răspuns dar fără termeni de interacțiune. Dacă aceasta este un cadru de date, acesta este considerat cadrul modelului (vezi model.frame).\n                </li>\n                <li>\n                data: un cadru de date opțional în care să se interpreteze variabilele numite în formulă.\n                </li>\n                <li>\n                weights: greutăți opționale pentru cazuri.\n                </li>\n                <li>\n                subset: o expresie opțională care spune că doar un subset din rândurile datelor ar trebui utilizat în potrivire.\n                </li>\n                <li>\n                na.action: acțiunea implicită șterge toate observațiile pentru care y este lipsă, dar păstrează acelea în care unul sau mai mulți predictori sunt lipsă.\n                </li>\n                <li>\n                method: unul dintre \"anova\", \"poisson\", \"class\" sau \"exp\". Dacă metoda este lipsă, rutina încearcă să facă o presupunere inteligentă. Dacă y este un obiect de supraviețuire, atunci metoda = \"exp\" este presupusă, dacă y are 2 coloane, atunci metoda = \"poisson\" este presupusă, dacă y este un factor, atunci metoda = \"class\" este presupusă, altfel metoda = \"anova\" este presupusă. Este cel mai înțelept să specificați metoda direct, mai ales că mai multe criterii pot fi adăugate funcției în viitor.\n                Alternativ, metoda poate fi o listă de funcții numite init, split și eval. Exemplele sunt date în fișierul 'tests/usersplits.R' în surse și în vignettele 'Funcții de Împărțire Scrise de Utilizatori'.\n                </li>\n                <li>\n                model: dacă este logic: păstrează o copie a cadrului modelului în rezultat? Dacă valoarea de intrare pentru model este un cadru de model (probabil dintr-un apel anterior la funcția rpart), atunci acest cadru este utilizat în loc să se construiască date noi.\n                </li>\n                <li>\n                x: păstrează o copie a matricei x în rezultat.\n                </li>\n                <li>\n                y: păstrează o copie a variabilei dependente în rezultat. Dacă este lipsă și modelul este furnizat, aceasta se presupune ca FALSE.\n                </li>\n                <li>\n                parms: parametrii opționali pentru funcția de împărțire.<br/>\n                Împărțirea Anova nu are parametrii.<br/>\n                Împărțirea Poisson are un singur parametru, coeficientul de variație al distribuției anterioare asupra ratelor. Valoarea implicită este 1.<br/>\n                Împărțirea Exponențială are același parametru ca Poisson.<br/>\n                Pentru împărțirea de clasificare, lista poate conține oricare dintre: vectorul de probabilități anterioare (componenta prior), matricea de pierdere (componenta pierdere) sau indicele de împărțire (componenta split). Priori trebuie să fie pozitive și să se adune la 1. Matricea de pierdere trebuie să aibă zerouri pe diagonală și elemente pozitive în afara diagonalei. Indicele de împărțire poate fi gini sau informație. Priori implicite sunt proporționale cu numărul de date, pierderile implicite sunt 1, iar împărțirea implicite este gini.<br/>\n                </li>\n                <li>\n                control: o listă de opțiuni care controlează detaliile algoritmului rpart. Vezi rpart.control.\n                </li>\n                <li>\n                cost: un vector de costuri non-negative, unul pentru fiecare variabilă din model. Implicit este 1 pentru toate variabilele. Acestea sunt scalări care trebuie aplicate atunci când se iau în considerare împărțirile, astfel încât îmbunătățirea împărțirii pe o variabilă este împărțită prin costul său în decizia privind alegerea împărțirii.\n                </li>\n                <li>\n                ...: argumentele pentru rpart.control pot fi de asemenea specificate în apelul la rpart. Acestea sunt verificate împotriva listei de argumente valide.\n                </li>\n                </ul>\n                <b>Detalii</b></br>\n                Aceasta diferă de funcția tree în S în principal în gestionarea variabilelor surrogate. În cele mai multe detalii, urmează destul de aproape Breiman et. al (1984). Pachetul R tree oferă o re-implementare a arborelui.\n                <b>Valoare</b></br>\n                Un obiect de clasă rpart. Vezi rpart.object.</br>\n                <b>Referințe</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., și Stone, C. J. (1984) Arbori de Clasificare și Regresie. Wadsworth.</br>\n                <b>Vezi De asemenea</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Exemple</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # altfel pe unele dispozitive textul este tăiat</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Pachet</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Ajutor</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>Descriere</b></br>\n                Control pentru Ajustările Rpart. Diverse parametrii care controlează aspectele ajustării rpart.\n                <br/>\n                <b>Utilizare</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                minsplit: numărul minim de observații care trebuie să existe într-un nod pentru ca o împărțire să fie încercată.\n                </li>\n                <li>\n                minbucket: numărul minim de observații în orice nod terminal <leaf>. Dacă doar unul dintre minbucket sau minsplit este specificat, codul fie setează minsplit la minbucket*3 sau minbucket la minsplit/3, după cum este cazul.\n                </li>\n                <li>\n                cp: parametru de complexitate. Orice împărțire care nu reduce lipsa generală de potrivire cu un factor de cp nu este încercată. De exemplu, cu împărțirea anova, aceasta înseamnă că R-pătratul general trebuie să crească cu cp la fiecare pas. Rolul principal al acestui parametru este de a economisi timp de calcul prin tăierea împărțirilor care nu sunt evident valoroase. Practic, utilizatorul informează programul că orice împărțire care nu îmbunătățește potrivirea cu cp va fi probabil tăiată prin validarea încrucișată, și că prin urmare programul nu trebuie să o urmărească.\n                </li>\n                <li>\n                maxcompete: numărul de împărțiri concurente reținute în ieșire. Este util să știți nu doar care împărțire a fost aleasă, ci și care variabilă a venit pe locul doi, trei etc.\n                </li>\n                <li>\n                maxsurrogate: numărul de împărțiri surrogate reținute în ieșire. Dacă aceasta este setată la zero, timpul de calcul va fi redus, deoarece aproximativ jumătate din timpul de calcul (în afară de configurare) este utilizat în căutarea împărțirilor surrogate.\n                </li>\n                <li>\n                usesurrogate: cum să folosiți surrogatele în procesul de împărțire. 0 înseamnă afișați doar; o observație cu o valoare lipsă pentru regula principală de împărțire nu este trimisă mai departe în arbore. 1 înseamnă utilizați surrogatele, în ordine, pentru a împărți subiecții lipsă de variabila principală; dacă toate surrogatele sunt lipsă, observația nu este împărțită. Pentru valoarea 2, dacă toate surrogatele sunt lipsă, atunci trimiteți observația în direcția majoritară. O valoare de 0 corespunde acțiunii arborelui, iar 2 recomandărilor lui Breiman et.al (1984).\n                </li>\n                <li>\n                xval: numărul de validări încrucișate.\n                </li>\n                <li>\n                surrogatestyle: controlează selecția unei cele mai bune surrogate. Dacă este setat la 0 (implicit), programul folosește numărul total de clasificări corecte pentru o variabilă surrogate potențială, dacă este setat la 1, folosește procentul corect, calculat pe valorile non-lipsă ale surrogate. Prima opțiune penalizează mai sever covariatele cu un număr mare de valori lipsă.\n                </li>\n                <li>\n                maxdepth: Setează adâncimea maximă a oricărui nod al arborelui final, cu nodul rădăcină numărat ca adâncime 0. Valorile mai mari de 30 rpart vor da rezultate fără sens pe mașinile de 32 de biți.\n                </li>\n                <li>\n                ...: adună alte argumente.\n                </li>\n                </ul>\n                <b>Valoare</b></br>\n                O listă care conține opțiunile. \n                      "
  }
}