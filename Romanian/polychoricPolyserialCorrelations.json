{
  "correlationType": "Tipul corelației",
  "Polychoric": "Policoric",
  "Polyserial": "Poliserial",
  "title": "Corelația policorică/poliserială",
  "bins": "Pentru corelațiile poliseriale - Numărul de bin-uri pentru testul de normalitate bivariată",
  "navigation": "Policoric, poliserial",
  "Target": "Selectați una sau mai multe variabile x",
  "textbox1": "Interval de încredere",
  "textbox2": "Ipoteza nulă (mu)",
  "Target2": "Selectați o singură variabilă factor ordonată y",
  "label1": "Tipul estimării",
  "test1": "Aproximare în două etape",
  "test2": "Estimarea maxim-likelihood",
  "label2": "Eroarea standard",
  "Missvals": "Afișați eroarea standard",
  "conflevel": "Corelația maximă absolută (pentru a asigura stabilitatea numerică).",
  "Seed": "Valoare de start opțională",
  "header": "Corelația este estimată între fiecare variabilă x și variabila y",
  "showEffectSizes": "Returnați pragurile estimate",
  "advanced_lbl" : "Avansat",
  "help": {
    "title": "Corelația policorică/poliserială",
    "r_help": "help(polychor, package ='polycor')",
    "body": "\n<b>Descriere</b></br>\nCalculează o corelație policorică sau poliserială. Corelația este estimată între fiecare variabilă x și variabila y\n<br/>\n<br/>\n<b>Descriere - Policoric</b></br>\nCalculează corelația policorică (și eroarea standard) între două variabile ordinale, sub presupunerea că variabilele ordinale disecă variabile latente continue care sunt bivariate normale. Fie estimarea maxim-likelihood, fie o aproximare „în două etape” (posibil mult) mai rapidă este disponibilă. Pentru estimarea ML, estimările pragurilor și matricea de covarianță a estimărilor sunt de asemenea disponibile.\n<br/>\n<b>Utilizare</b>\n<br/>\n<code> \npolychor(x, y, ML = FALSE, control = list(), \n  std.err = FALSE, maxcor=.9999, start, thresholds=FALSE)\n</code> <br/>\n<b>Argumente</b><br/>\n<ul>\n<li>\nx: variabilă categorială ordonată; variabila poate fi numerică, logică, un factor, un factor ordonat sau o variabilă de tip caracter, dar dacă este un factor, nivelurile sale ar trebui să fie în ordinea corectă, iar valorile unei variabile de tip caracter sunt ordonate alfabetic.\n</li>\n<li>\ny: o variabilă factor ordonată\n</li>\n<li>\nML: dacă este TRUE, calculează estimarea maxim-likelihood; dacă este FALSE, implicit, calculează o aproximare „în două etape” mai rapidă.\n</li>\n<li>\nstd.err: dacă este TRUE, returnează varianta estimată a corelației (pentru estimatorul în două etape) sau matricea de covarianță estimată (pentru estimatorul ML) a corelației și pragurilor; implicit este FALSE. \n</li>\n<li>\nmaxcor: corelația maximă absolută (pentru a asigura stabilitatea numerică).\n</li>\n<li>\nstart: valori de start opționale: dacă este un singur număr, valoare de start pentru corelație.\n</li>\n<li>\nthresholds: dacă este TRUE (implicit este FALSE) returnează pragurile estimate împreună cu corelația estimată chiar dacă erorile standard nu sunt calculate.\n</li>\n</ul>\n<b>Valori</b></br>\nValoare: Dacă std.err sau thresholds este TRUE, returnează un obiect de clasă \"polycor\" cu următoarele componente:</br>\ntype: setat pe \"policoric\".</br>\nrho: corelația policorică.</br>\nrow.cuts: pragurile estimate pentru variabila de rând (x), pentru estimarea ML.</br>\ncol.cuts: pragurile estimate pentru variabila de coloană (y), pentru estimarea ML.</br>\nvar: varianta estimată a corelației, sau, pentru estimarea ML, matricea de covarianță estimată a corelației și pragurilor.</br>\nn: numărul de observații pe care se bazează corelația.</br>\nchisq: test chi-pătrat pentru normalitate bivariată.</br>\ndf: gradele de libertate pentru testul de normalitate bivariată.</br>\nML: TRUE pentru estimarea ML, FALSE pentru estimarea în două etape\n<b>Detalii</b></br>\nEstimarea ML este calculată prin maximizarea verosimilității bivariate-normale în raport cu pragurile pentru cele două variabile (τ^x[i], i = 1,…, r - 1; τ^y[j], j = 1,…, c - 1) și corelația populației (ρ). Aici, r și c sunt respectiv numărul de niveluri ale x și y. Verosimilitatea este maximizată numeric folosind funcția optim, iar matricea de covarianță a parametrilor estimați se bazează pe Hessianul numeric calculat de optim.</br>\nEstimarea în două etape este calculată prin estimarea mai întâi a pragurilor (τ^x[i], i = 1,…, r - 1 și τ^y[j], i = j,…, c - 1) separat din distribuția marginală a fiecărei variabile. Apoi, verosimilitatea unidimensională pentru ρ este maximizată numeric, folosind optim dacă erorile standard sunt solicitate, sau optimise dacă nu sunt. Eroarea standard calculată tratează pragurile ca fiind fixe.\n<br/>\n<b>Exemplu</b></br>\n<code> \nif(require(mvtnorm)){\n    set.seed(12345)\n    data <- rmvnorm(1000, c(0, 0), matrix(c(1, .5, .5, 1), 2, 2))\n    x <- data[,1]\n    y <- data[,2]\n    cor(x, y)  # corelația de probă\n    }\n\nif(require(mvtnorm)){\n    x <- cut(x, c(-Inf, .75, Inf))\n    y <- cut(y, c(-Inf, -1, .5, 1.5, Inf))\n    polychor(x, y)  # estimare în 2 etape\n    }\n\nif(require(mvtnorm)){\n    polychor(x, y, ML=TRUE, std.err=TRUE)  # estimare ML\n    }\n</code> <br/>\n<b>Pachet</b></br>\npolycor</br>\n<b>Ajutor</b></br>\nPentru ajutor detaliat, faceți clic pe pictograma R din colțul din dreapta sus al acestui dialog sau rulați următoarea comandă help(polycor, package ='polychor') creând un chunk de cod R făcând clic pe + în fereastra de ieșire           \n<br/>\n<br/>\n<b>Descriere - Poliserial</b></br>\nCalculează corelația poliserială (și eroarea standard) între o variabilă cantitativă și o variabilă ordinală, pe baza presupunerii că distribuția comună a variabilei cantitative și a unei variabile continue latente care stă la baza variabilei ordinale este bivariată normală. Fie estimarea maxim-likelihood, fie o aproximare „în două etape” mai rapidă este disponibilă. Pentru estimarea ML, estimările pragurilor și matricea de covarianță a estimărilor sunt de asemenea disponibile.\n<br/>\n<b>Utilizare</b>\n<br/>\n<code> \npolyserial(x, y, ML = FALSE, control = list(), \n  std.err = FALSE, maxcor=.9999, bins=4, start, thresholds=FALSE)\n</code> <br/>\n<b>Argumente</b><br/>\n<ul>\n<li>\nx: o variabilă numerică\n</li>\n<li>\ny: o variabilă categorială ordonată; poate fi numerică, logică, un factor, un factor ordonat sau o variabilă de tip caracter, dar dacă este un factor, nivelurile sale ar trebui să fie în ordinea corectă, iar valorile unei variabile de tip caracter sunt ordonate alfabetic.\n</li>\n<li>\nML: dacă este TRUE, calculează estimarea maxim-likelihood; dacă este FALSE, implicit, calculează o aproximare „în două etape” mai rapidă.\n</li>\n<li>\nstd.err: dacă este TRUE, returnează varianta estimată a corelației (pentru estimatorul în două etape) sau matricea de covarianță estimată (pentru estimatorul ML) a corelației și pragurilor; implicit este FALSE. \n</li>\n<li>\nbins: numărul de bin-uri în care să disecați x pentru un test de normalitate bivariată; implicit este 4.\n</li>\n<li>\nmaxcor: corelația maximă absolută (pentru a asigura stabilitatea numerică).\n</li>\n<li>\nstart: valori de start opționale: dacă este un singur număr, valoare de start pentru corelație.\n</li>\n<li>\nthresholds: dacă este TRUE (implicit este FALSE) returnează pragurile estimate împreună cu corelația estimată chiar dacă erorile standard nu sunt calculate.\n</li>\n</ul>\n<b>Valori</b></br>\nValoare: Dacă std.err sau thresholds este TRUE, returnează un obiect de clasă \"polycor\" cu următoarele componente:</br>\ntype: setat pe \"poliserial\".</br>\nrho: corelația poliserială.</br>\ncuts: pragurile estimate pentru variabila ordinală (y), pentru estimarea ML.</br>\nvar: varianta estimată a corelației, sau, pentru estimarea ML, matricea de covarianță estimată a corelației și pragurilor.</br>\nn: numărul de observații pe care se bazează corelația.</br>\nchisq: test chi-pătrat pentru normalitate bivariată.</br>\ndf: gradele de libertate pentru testul de normalitate bivariată.</br>\nML: TRUE pentru estimarea ML, FALSE pentru estimarea în două etape\n<b>Exemplu</b></br>\n<code> \nif(require(mvtnorm)){\n    set.seed(12345)\n    data <- rmvnorm(1000, c(0, 0), matrix(c(1, .5, .5, 1), 2, 2))\n    x <- data[,1]\n    y <- data[,2]\n    cor(x, y)  # corelația de probă\n    }\n\nif(require(mvtnorm)){\n    y <- cut(y, c(-Inf, -1, .5, 1.5, Inf))\n    polyserial(x, y)  # estimare în 2 etape\n    }\n\nif(require(mvtnorm)){\n    polyserial(x, y, ML=TRUE, std.err=TRUE) # estimare ML\n    }\n\n</code> <br/>\n<b>Pachet</b></br>\npolycor</br>\n<b>Ajutor</b></br>\nPentru ajutor detaliat, rulați următoarea comandă help(polyserial, package ='polychor') creând un chunk de cod R făcând clic pe + în fereastra de ieșire           \n\n\t\t\t"
  }
}