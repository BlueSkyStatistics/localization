{
  "title": "Sıralı Regresyon",
  "navigation": "Sıralı",
  "label1": "Test yöntemi",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Model adını girin",
  "dependent": "Bağımlı değişken",
  "formula": "Bağımsız değişken(ler)",
  "generateplotchk": "Artıklar ile uyumlu, normal Q-Q, ölçek-konum ve artıklar ile kaldıraçlar arasındaki grafiği oluştur",
  "weights": "Ağırlıklarla bir değişken belirtin",
  "help": {
    "title": "Sıralı",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Açıklama</b></br>\n            Sıralı faktör yanıtına bir lojistik veya probit regresyon modeli uydurur. Varsayılan lojistik durumu, işlevin adını aldığı orantılı olasılık lojistik regresyonudur.\n            <br/>\n            <b>Kullanım</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argümanlar</b><br/>\n            <ul>\n            <li>\n            formula: regresyon modelleri için bir formül ifadesi, yanıt ~ tahmin ediciler biçiminde. Yanıt bir faktör (tercihen sıralı bir faktör) olmalıdır ve sıralı bir yanıt olarak yorumlanacaktır, seviyeler faktördeki gibi sıralanmıştır. Modelin bir kesme noktası olmalıdır: birini kaldırmaya çalışmak bir uyarıya yol açacak ve göz ardı edilecektir. Bir offset kullanılabilir. Diğer detaylar için formül belgelerine bakın.\n            </li>\n            <li>\n            data: formülde geçen değişkenleri yorumlamak için isteğe bağlı bir veri çerçevesi.\n            </li>\n            <li>\n            weights: uyumda isteğe bağlı durum ağırlıkları. Varsayılan 1'dir.\n            </li>\n            <li>\n            start: parametreler için başlangıç değerleri. Bu, c(katsayılar, zeta) formatındadır: Değerler bölümüne bakın.\n            </li>\n            <li>\n            ... optim'e geçilecek ek argümanlar, en sık bir kontrol argümanı.\n            </li>\n            <li>\n            subset: verilerin hangi satır alt kümesinin uyumda kullanılacağını belirten bir ifade. Varsayılan olarak tüm gözlemler dahildir.\n            </li>\n            <li>\n            na.action: eksik verileri filtrelemek için bir işlev.\n            </li>\n            <li>\n            contrasts: model formülünde değişken olarak görünen bazı veya tüm faktörler için kullanılacak bir kontrastlar listesi.\n            </li>\n            <li>\n            Hess: Hessian'ın (gözlemlenen bilgi matrisinin) döndürülüp döndürülmeyeceği için mantıksal. Uyumda özet veya vcov çağırmayı planlıyorsanız bunu kullanın.\n            </li>\n            <li>\n            model: model matrisinin döndürülüp döndürülmeyeceği için mantıksal.\n            </li>\n            <li>\n            method: lojistik veya probit veya (tamamlayıcı) log-log veya cauchit (bir Cauchy gizli değişkenine karşılık gelir).\n            </li>\n            </ul>\n            <b>Ayrıntılar</b></br>\n            Bu model, Agresti (2002) tarafından birikimli bağlantı modeli olarak adlandırılır. Temel yorum, bir lojistik veya normal veya aşırı değer veya Cauchy dağılımına sahip Y_i gizli değişkeninin kabaca bir versiyonu olarak yorumlanır ve ortalama için bir doğrusal model vardır. Gözlemlenen sıralı faktör, Y_i'nin hangi kutuya düştüğüdür ve kesim noktaları\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Bu, aşağıdaki modele yol açar</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            logit, normal bir gizli değişken için probit ile değiştirilir ve eta, açıklayıcı değişkenlerin (kesme noktası olmadan) doğrusal bir fonksiyonu olan doğrusal tahmincidir. Diğer yazılımların eta için ters işareti kullanması oldukça yaygındır (ve dolayısıyla katsayılar beta).\n            Lojistik durumda, son gösterimin sol tarafı k veya daha az kategori için log olasılıktır ve bu, farklı k'ler için yalnızca bir sabit ile farklı olan log olasılıklardır, bu nedenle olasılıklar orantılıdır. Bu nedenle, orantılı olasılık lojistik regresyonu terimi.\n            Log-log ve tamamlayıcı log-log bağlantıları, artan fonksiyonlardır F^-1(p) = -log(-log(p)) ve F^-1(p) = log(-log(1-p)); bazıları ilkini 'negatif log-log' bağlantısı olarak adlandırır. Bu, maksimum ve minimum için aşırı değer dağılımına sahip bir gizli değişkenle karşılık gelir.\n            Gruplandırılmış hayatta kalma süreleri için orantılı tehlike modeli, artan zamanlarla sıralanmış gruplama ile tamamlayıcı log-log bağlantısını kullanarak elde edilebilir.\n            predict, summary, vcov, anova, model.frame ve stepAIC (ve step) ile kullanılacak bir extractAIC yöntemi vardır. Ayrıca profil ve confint yöntemleri de vardır.</br>\n            <b>Değer</b><br/>\n            \"polr\" sınıfından bir nesne. Bu, bileşenlere sahiptir\n            <li>\n            coefficients: kesme noktası olmayan doğrusal tahmincinin katsayıları.\n            </li>\n            <li>\n            zeta: sınıf sınırları için kesme noktaları.\n            </li>\n            <li>\n            deviance: artık deviance.\n            </li>\n            <li>\n            fitted.values: yanıtın her seviyesi için bir sütun içeren bir matris.\n            </li>\n            <li>\n            lev: yanıt seviyelerinin adları.\n            </li>\n            <li>\n            terms: modeli tanımlayan terimler yapısı.\n            </li>\n            <li>\n            df.residual: ağırlıkları kullanarak hesaplanan kalıntı serbestlik dereceleri sayısı.\n            </li>\n            <li>\n            edf: model tarafından kullanılan (etkili) serbestlik dereceleri sayısı\n            </li>\n            <li>\n            n, nobs: ağırlıkları kullanarak hesaplanan (etkili) gözlem sayısı. (nobs, stepAIC tarafından kullanılmak içindir).\n            </li>\n            <li>\n            call: eşleşen çağrı.\n            </li>\n            <li>\n            method: kullanılan eşleşen yöntem.\n            </li>\n            <li>\n            convergence: optim tarafından döndürülen yakınsama kodu.\n            </li>\n            <li>\n            niter: optim tarafından kullanılan fonksiyon ve gradyan değerlendirmelerinin sayısı.\n            </li>\n            <li>\n            lp: doğrusal tahminci (herhangi bir offset dahil).\n            </li>\n            <li>\n            Hessian: (eğer Hess doğruysa). Bu, optimizasyon sürecinden türetilen bir sayısal yaklaşımdır.\n            </li>\n            <li>\n            model: (eğer model doğruysa).\n            </li>\n            <li>\n            Not</br>\n            vcov yöntemi yaklaşık Hessian kullanır: güvenilir sonuçlar için model matrisinin tüm sütunlarının bir aralıkta makul bir şekilde ölçeklendirilmesi gerekir.\n            Sürüm 7.3-32'den önce, method = \"cloglog\" kafa karıştırıcı bir şekilde log-log bağlantısını verdi, ilk yanıt seviyesinin 'en iyi' olduğunu varsayarak.\n            <br/>\n            <b>Örnekler</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## biraz daha kötü uyumdan<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## uygun olmasa da, uyum sağlayabilir<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Paket</b></br>\n            MASS</br>\n            <b>Yardım</b></br>\n            Ayrıntılı yardım için bu diyalog üst kısmındaki R simgesine tıklayın veya bir R kodu parçası oluşturarak help(polr, package =MASS) komutunu çalıştırın."
  }
}