{
  "title": "Karar Ağaçları",
  "navigation": "Karar Ağaçları",
  "TxtTreeName": "Model Adını Girin",
  "TreeGenChkbox": "Ağaç zaten mevcutsa yeniden oluşturma",
  "dependent": "Bağımlı değişken",
  "independent": "Bağımsız değişken(ler)",
  "weights": "Anket ağırlıkları",
  "TxtMinSplit": "Minimum bölme",
  "minBucket": "Minimum sepet",
  "TxtCP": "Karmaşıklık parametresi",
  "maxDepth": "Maksimum derinlik",
  "PruneTreeChkbox": "Ağacı buda",
  "rd0": "Budama yok",
  "rd1": "Optimal karmaşıklık parametresini kullan",
  "rd2": "Karmaşıklık parametresini belirt",
  "TxtCPPrune": "Karmaşıklık parametresini girin",
  "PlotCVChkbox": "Çapraz doğrulama grafiği",
  "PlotRSQRChkbox": "R-kare grafiği",
  "OptvarPlots": "Grafikler",
  "OptvarPreprune": "Ön Budama",
  "OptvarPrune": "Ağacı Budama",
  "help": {
    "title": "Karar Ağaçları",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>Not</b></br>\n                Bağımlı değişkenler faktör, sıralı, dize, mantıksal ve sayısal olabilir</br>\n                Bağımsız Değişkenler faktör, sıralı, dize, mantıksal ve sayısal olabilir</br></br>\n                <b>Açıklama</b></br>\n                Bir Yinelemeli Bölme ve Regresyon Ağaç modeli oluşturun\n                <br/>\n                <b>Kullanım</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>Argümanlar</b><br/>\n                <ul>\n                <li>\n                formula: bir yanıtı olan ancak etkileşim terimleri olmayan bir formül. Eğer bu bir veri çerçevesiyse, model çerçevesi olarak alınır (bkz. model.frame).\n                </li>\n                <li>\n                data: formülde adlandırılan değişkenleri yorumlamak için isteğe bağlı bir veri çerçevesi.\n                </li>\n                <li>\n                weights: isteğe bağlı durum ağırlıkları.\n                </li>\n                <li>\n                subset: yalnızca veri çerçevesinin bir alt kümesinin uyumda kullanılacağını belirten isteğe bağlı bir ifade.\n                </li>\n                <li>\n                na.action: varsayılan eylem, y'nin eksik olduğu tüm gözlemleri siler, ancak bir veya daha fazla tahmin edici eksik olanları korur.\n                </li>\n                <li>\n                method: \"anova\", \"poisson\", \"class\" veya \"exp\"'den biri. Yöntem eksikse, rutin akıllıca bir tahminde bulunmaya çalışır. Eğer y bir hayatta kalma nesnesiyse, o zaman method = \"exp\" varsayılır, eğer y'nin 2 sütunu varsa o zaman method = \"poisson\" varsayılır, eğer y bir faktörse o zaman method = \"class\" varsayılır, aksi takdirde method = \"anova\" varsayılır. Yöntemi doğrudan belirtmek en iyisidir, özellikle gelecekte işlevin daha fazla kriter eklenebileceği göz önüne alındığında.\n                Alternatif olarak, yöntem, init, split ve eval adında işlevlerin bir listesidir. Örnekler, kaynaklardaki 'tests/usersplits.R' dosyasında ve 'Kullanıcı Yazılı Bölme Fonksiyonları' başlıklı broşürlerde verilmiştir.\n                </li>\n                <li>\n                model: mantıksal ise: sonuçta model çerçevesinin bir kopyasını sakla mı? Eğer model için giriş değeri bir model çerçevesiyse (muhtemelen daha önceki bir rpart çağrısından), o zaman bu çerçeve yeni veri oluşturmak yerine kullanılır.\n                </li>\n                <li>\n                x: sonuçta x matrisinin bir kopyasını sakla.\n                </li>\n                <li>\n                y: sonuçta bağımlı değişkenin bir kopyasını sakla. Eksikse ve model sağlanmışsa bu varsayılan olarak FALSE olur.\n                </li>\n                <li>\n                parms: bölme işlevi için isteğe bağlı parametreler.<br/>\n                Anova bölmesi parametre içermez.<br/>\n                Poisson bölmesi, oranların ön dağılımının varyasyon katsayısı olan tek bir parametreye sahiptir. Varsayılan değer 1'dir.<br/>\n                Üstel bölme, Poisson ile aynı parametreye sahiptir.<br/>\n                Sınıflandırma bölmesi için liste, herhangi birini içerebilir: öncelik olasılıkları vektörü (bileşen öncelik), kayıp matris (bileşen kayıp) veya bölme indeksi (bileşen bölme). Öncelikler pozitif olmalı ve 1'e toplamları gerekmektedir. Kayıp matrisinin diyagonalinde sıfırlar ve pozitif dış-diyagonal elemanlar olmalıdır. Bölme indeksi gini veya bilgi olabilir. Varsayılan öncelikler veri sayımlarına orantılıdır, kayıplar varsayılan olarak 1'dir ve bölme varsayılan olarak gini'dir.<br/>\n                </li>\n                <li>\n                control: rpart algoritmasının ayrıntılarını kontrol eden bir seçenekler listesi. rpart.control'a bakın.\n                </li>\n                <li>\n                cost: modeldeki her değişken için bir tane olmak üzere, sıfırdan büyük maliyetlerin bir vektörü. Tüm değişkenler için varsayılan olarak bir olarak ayarlanır. Bunlar bölmeleri düşünürken uygulanacak ölçeklerdir, bu nedenle bir değişken üzerinde bölme yapmanın iyileştirmesi, hangi bölmeyi seçeceğini belirlerken maliyetine bölünür.\n                </li>\n                <li>\n                ...: rpart.control'a yapılan çağrıda da belirtilen argümanlar geçerli argümanlar listesiyle kontrol edilir.\n                </li>\n                </ul>\n                <b>Ayrıntılar</b></br>\n                Bu, S'deki ağaç işlevinden esasen ikincil değişkenlerin işlenmesi açısından farklıdır. Çoğu ayrıntıda Breiman ve diğerleri (1984) ile oldukça yakından takip eder. R paketi ağaç, ağaç işlevinin yeniden uygulanmasını sağlar.\n                <b>Değer</b></br>\n                rpart sınıfının bir nesnesi. rpart.object'e bakın.</br>\n                <b>Kaynaklar</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., ve Stone, C. J. (1984) Sınıflandırma ve Regresyon Ağaçları. Wadsworth.</br>\n                <b>Ayrıca Bakınız</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Örnekler</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # aksi takdirde bazı cihazlarda metin kesilir</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Paket</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Yardım</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>Açıklama</b></br>\n                Rpart Uygulamaları için Kontrol. Rpart uyumunun yönlerini kontrol eden çeşitli parametreler.\n                <br/>\n                <b>Kullanım</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argümanlar</b><br/>\n                <ul>\n                <li>\n                minsplit: bir düğümde bir bölme denemesi için mevcut olması gereken minimum gözlem sayısı.\n                </li>\n                <li>\n                minbucket: herhangi bir terminal <leaf> düğümündeki minimum gözlem sayısı. Eğer yalnızca minbucket veya minsplit belirtilirse, kod ya minsplit'i minbucket*3 olarak ya da minbucket'ı minsplit/3 olarak ayarlar, uygun olduğunda.\n                </li>\n                <li>\n                cp: karmaşıklık parametresi. Toplam uyumsuzluğu cp faktörü kadar azaltmayan herhangi bir bölme denemesi yapılmaz. Örneğin, anova bölmesi ile bu, toplam R-karenin her adımda cp kadar artması gerektiği anlamına gelir. Bu parametrenin ana rolü, açıkça değerli olmayan bölmeleri budayarak hesaplama süresini tasarruf etmektir. Temelde, kullanıcı programa, cp kadar uyumu artırmayan herhangi bir bölmenin muhtemelen çapraz doğrulama ile budanacağını ve bu nedenle programın bunu takip etmesine gerek olmadığını bildirir.\n                </li>\n                <li>\n                maxcompete: çıktıda tutulan rakip bölmelerin sayısı. Sadece hangi bölmenin seçildiğini değil, hangi değişkenin ikinci, üçüncü vb. olduğunu bilmek de faydalıdır.\n                </li>\n                <li>\n                maxsurrogate: çıktıda tutulan ikincil bölmelerin sayısı. Bu sıfıra ayarlanırsa, hesaplama süresi azaltılacaktır, çünkü yaklaşık olarak hesaplama süresinin yarısı (kurulum dışında) ikincil bölmelerin aranmasında kullanılır.\n                </li>\n                <li>\n                usesurrogate: bölme sürecinde ikincil değişkenlerin nasıl kullanılacağını belirtir. 0 yalnızca görüntüleme anlamına gelir; birincil bölme kuralı için eksik bir değere sahip bir gözlem daha fazla ağaçta gönderilmez. 1, birincil değişkeni eksik olan denekleri bölmek için ikincil değişkenleri sırayla kullanır; eğer tüm ikincil değişkenler eksikse gözlem bölünmez. 2 değeri için, eğer tüm ikincil değişkenler eksikse, gözlemi çoğunluk yönünde gönderir. 0 değeri, ağaç işlevinin eylemine karşılık gelir ve 2, Breiman ve diğerlerinin (1984) önerilerine karşılık gelir.\n                </li>\n                <li>\n                xval: çapraz doğrulama sayısı.\n                </li>\n                <li>\n                surrogatestyle: en iyi ikincil değişkenin seçimini kontrol eder. 0 (varsayılan) olarak ayarlanırsa, program potansiyel bir ikincil değişken için doğru sınıflandırma sayısını kullanır, 1 olarak ayarlanırsa, ikincil değişkenin eksik olmayan değerleri üzerinden hesaplanan doğru yüzdeleri kullanır. İlk seçenek, eksik değerleri olan değişkenleri daha sert bir şekilde cezalandırır.\n                </li>\n                <li>\n                maxdepth: son ağacın herhangi bir düğümünün maksimum derinliğini ayarlar, kök düğüm derinlik 0 olarak sayılır. 30'dan büyük değerler rpart, 32-bit makinelerde mantıksal sonuçlar vermez.\n                </li>\n                <li>\n                ...: diğer argümanları toplar.\n                </li>\n                </ul>\n                <b>Değer</b></br>\n                Seçenekleri içeren bir liste. \n                      "
  }
}