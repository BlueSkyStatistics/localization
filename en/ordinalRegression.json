{
    "title": "Ordinal Regression",
    "navigation": "Ordinal",
    "label1": "Test method",
    "logit": "Logit",
    "probit": "Probit",
    "modelname": "Enter model name",
    "dependent": "Dependent variable",
    "formula": "Independent variable(s)",
    "generateplotchk": "Plot residuals vs fitted, normal Q-Q , scale-location and residuals vs leverage",
    "weights": "Specify a variable with weights",
    "help": {
        "title": "Ordinal",
        "r_help": "help(polr, package=MASS)",
        "body": "\n            <b>Description</b></br>\n            Fits a logistic or probit regression model to an ordered factor response. The default logistic case is proportional odds logistic regression, after which the function is named.\n            <br/>\n            <b>Usage</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Arguments</b><br/>\n            <ul>\n            <li>\n            formula: a formula expression as for regression models, of the form response ~ predictors. The response should be a factor (preferably an ordered factor), which will be interpreted as an ordinal response, with levels ordered as in the factor. The model must have an intercept: attempts to remove one will lead to a warning and be ignored. An offset may be used. See the documentation of formula for other details.\n            </li>\n            <li>\n            data: an optional data frame in which to interpret the variables occurring in formula.\n            </li>\n            <li>\n            weights: optional case weights in fitting. Default to 1.\n            </li>\n            <li>\n            start: initial values for the parameters. This is in the format c(coefficients, zeta): see the Values section.\n            </li>\n            <li>\n            ... additional arguments to be passed to optim, most often a control argument.\n            </li>\n            <li>\n            subset: expression saying which subset of the rows of the data should be used in the fit. All observations are included by default.\n            </li>\n            <li>\n            na.action: a function to filter missing data.\n            </li>\n            <li>\n            contrasts: a list of contrasts to be used for some or all of the factors appearing as variables in the model formula.\n            </li>\n            <li>\n            Hess: logical for whether the Hessian (the observed information matrix) should be returned. Use this if you intend to call summary or vcov on the fit.\n            </li>\n            <li>\n            model: logical for whether the model matrix should be returned.\n            </li>\n            <li>\n            method: logistic or probit or (complementary) log-log or cauchit (corresponding to a Cauchy latent variable).\n            </li>\n            </ul>\n            <b>Details</b></br>\n            This model is what Agresti (2002) calls a cumulative link model. The basic interpretation is as a coarsened version of a latent variable Y_i which has a logistic or normal or extreme-value or Cauchy distribution with scale parameter one and a linear model for the mean. The ordered factor which is observed is which bin Y_i falls into with breakpoints\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            This leads to the model</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            with logit replaced by probit for a normal latent variable, and eta being the linear predictor, a linear function of the explanatory variables (with no intercept). Note that it is quite common for other software to use the opposite sign for eta (and hence the coefficients beta).</br>\n            In the logistic case, the left-hand side of the last display is the log odds of category k or less, and since these are log odds which differ only by a constant for different k, the odds are proportional. Hence the term proportional odds logistic regression.</br>\n            The log-log and complementary log-log links are the increasing functions F^-1(p) = -log(-log(p)) and F^-1(p) = log(-log(1-p)); some call the first the ‘negative log-log’ link. These correspond to a latent variable with the extreme-value distribution for the maximum and minimum respectively.</br>\n            A proportional hazards model for grouped survival times can be obtained by using the complementary log-log link with grouping ordered by increasing times.</br>\n            predict, summary, vcov, anova, model.frame and an extractAIC method for use with stepAIC (and step). There are also profile and confint methods.</br>\n            <b>Value</b><br/>\n            A object of class \"polr\". This has components\n            <li>\n            coefficients: the coefficients of the linear predictor, which has no intercept.\n            </li>\n            <li>\n            zeta: the intercepts for the class boundaries.\n            </li>\n            <li>\n            deviance: the residual deviance.\n            </li>\n            <li>\n            fitted.values: a matrix, with a column for each level of the response.\n            </li>\n            <li>\n            lev: the names of the response levels.\n            </li>\n            <li>\n            terms: the terms structure describing the model.\n            </li>\n            <li>\n            df.residual: the number of residual degrees of freedoms, calculated using the weights.\n            </li>\n            <li>\n            edf: the (effective) number of degrees of freedom used by the model\n            </li>\n            <li>\n            n, nobs: the (effective) number of observations, calculated using the weights. (nobs is for use by stepAIC.\n            </li>\n            <li>\n            call: the matched call.\n            </li>\n            <li>\n            method: the matched method used.\n            </li>\n            <li>\n            convergence: the convergence code returned by optim.\n            </li>\n            <li>\n            niter: the number of function and gradient evaluations used by optim.\n            </li>\n            <li>\n            lp: the linear predictor (including any offset).</li>\n            <li>\n            Hessian: (if Hess is true). Note that this is a numerical approximation derived from the optimization process.\n            </li>\n            <li>\n            model:(if model is true).\n            </li>\n            <li>\n            Note</br>\n            The vcov method uses the approximate Hessian: for reliable results the model matrix should be sensibly scaled with all columns having range the order of one.</br>\n            Prior to version 7.3-32, method = \"cloglog\" confusingly gave the log-log link, implicitly assuming the first response level was the ‘best’.</br>\n            <br/>\n            <b>Examples</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## slightly worse fit from<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## although it is not really appropriate, can fit<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Package</b></br>\n            MASS</br>\n            <b>Help</b></br>\n            For detailed help click on the R icon on the top right hand side of this dialog overlay or run the following command help(polr, package =MASS) by creating a R code chunk by clicking + in the output window\t\t\t"
    }
}