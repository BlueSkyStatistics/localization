{
  "title": "Correlación Policórica",
  "navigation": "Policórica",
  "Target": "Seleccione una o más variables x",
  "textbox1": "Intervalo de confianza",
  "textbox2": "Hipótesis nula (mu)",
  "Target2": "Seleccione una única variable de factor ordenado y",
  "label1": "Tipo de estimación",
  "test1": "Aproximación de dos pasos",
  "test2": "Estimador de máxima verosimilitud",
  "label2": "Error estándar",
  "Missvals": "Mostrar error estándar",
  "conflevel": "Correlación absoluta máxima (para asegurar estabilidad numérica).",
  "Seed": "Valor(es) de inicio opcional(es)",
  "header": "La correlación se estima entre cada variable x y la variable y",
  "showEffectSizes": "Devolver umbrales estimados",
  "advanced_lbl" : "Avanzado",
  "help": {
    "title": "Correlación Policórica",
    "r_help": "help(polychor, package ='polycor')",
    "body": "\n<b>Descripción</b></br>\nCalcula la correlación policórica (y su error estándar) entre dos variables ordinales, bajo la suposición de que las variables ordinales disecan variables latentes continuas que son bivariadas normales. Está disponible el estimador de máxima verosimilitud o una aproximación de \"dos pasos\" (posiblemente mucho) más rápida.\n<br/>\n<b>Uso</b>\n<br/>\n<code> \npolychor(x, y, ML = FALSE, control = list(), \n  std.err = FALSE, maxcor=.9999, start, thresholds=FALSE)\n</code> <br/>\n<b>Argumentos</b><br/>\n<ul>\n<li>\nx: variable categórica ordenada; la variable puede ser numérica, lógica, un factor, un factor ordenado o una variable de carácter, pero si es un factor, sus niveles deben estar en el orden correcto, y los valores de una variable de carácter están ordenados alfabéticamente.\n</li>\n<li>\ny: una variable de factor ordenado\n</li>\n<li>\nML: si es VERDADERO, calcula la estimación de máxima verosimilitud; si es FALSO, por defecto, calcula una aproximación más rápida de \"dos pasos\".\n</li>\n<li>\nstd.err: si es VERDADERO, devuelve la varianza estimada de la correlación (para el estimador de dos pasos) o la matriz de covarianza estimada (para el estimador de ML) de la correlación y los umbrales; el valor por defecto es FALSO. \n</li>\n<li>\nmaxcor: correlación absoluta máxima (para asegurar estabilidad numérica).\n</li>\n<li>\nstart:  valor(es) de inicio opcional(es): si es un solo número, valor de inicio para la correlación.\n</li>\n<li>\nthresholds:  si es VERDADERO (el valor por defecto es FALSO) devuelve umbrales estimados junto con la correlación estimada incluso si no se calculan errores estándar.\n</li>\n</ul>\n<b>Valores</b></br>\nValor: Si std.err o thresholds es VERDADERO, devuelve un objeto de clase \"polycor\" con los siguientes componentes:</br>\ntipo: establecido en \"policórica\".</br>\nrho: la correlación policórica.</br>\nrow.cuts: umbrales estimados para la variable de fila (x), para la estimación de ML.</br>\ncol.cuts: umbrales estimados para la variable de columna (y), para la estimación de ML.</br>\nvar: la varianza estimada de la correlación, o, para la estimación de ML, la matriz de covarianza estimada de la correlación y los umbrales.</br>\nn: el número de observaciones en las que se basa la correlación.</br>\nchisq: prueba de chi-cuadrado para la normalidad bivariada.</br>\ndf: grados de libertad para la prueba de normalidad bivariada.</br>\nML: VERDADERO para la estimación de ML, FALSO para la estimación de dos pasos\n<b>Detalles</b></br>\nEl estimador de ML se calcula maximizando la verosimilitud bivariada-normal con respecto a los umbrales para las dos variables (τ^x[i], i = 1,…, r - 1; τ^y[j], j = 1,…, c - 1) y la correlación poblacional (ρ). Aquí, r y c son respectivamente el número de niveles de x e y. La verosimilitud se maximiza numéricamente utilizando la función optim, y la matriz de covarianza de los parámetros estimados se basa en el Hessiano numérico calculado por optim.</br>\nEl estimador de dos pasos se calcula primero estimando los umbrales (τ^x[i], i = 1,…, r - 1 y τ^y[j], i = j,…, c - 1) por separado de la distribución marginal de cada variable. Luego, la verosimilitud unidimensional para ρ se maximiza numéricamente, utilizando optim si se solicitan errores estándar, o optimise si no se solicitan. El error estándar calculado trata los umbrales como fijos.\n<br/>\n<b>Ejemplo</b></br>\n<code> \nif(require(mvtnorm)){\n    set.seed(12345)\n    data <- rmvnorm(1000, c(0, 0), matrix(c(1, .5, .5, 1), 2, 2))\n    x <- data[,1]\n    y <- data[,2]\n    cor(x, y)  # correlación de muestra\n    }\n\nif(require(mvtnorm)){\n    x <- cut(x, c(-Inf, .75, Inf))\n    y <- cut(y, c(-Inf, -1, .5, 1.5, Inf))\n    polychor(x, y)  # estimación de 2 pasos\n    }\n\nif(require(mvtnorm)){\n    polychor(x, y, ML=TRUE, std.err=TRUE)  # estimación de ML\n    }\n</code> <br/>\n<b>Paquete</b></br>\npolycor</br>\n<b>Ayuda</b></br>\nPara ayuda detallada, haga clic en el ícono de R en la parte superior derecha de este diálogo o ejecute el siguiente comando help(polycor, package ='polychor') creando un bloque de código R haciendo clic en + en la ventana de salida           \n    "
  }
}