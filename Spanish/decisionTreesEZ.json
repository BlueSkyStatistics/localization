{
  "title": "Árboles de Decisión",
  "navigation": "Árboles de Decisión",
  "TxtTreeName": "Ingrese el nombre del modelo",
  "TreeGenChkbox": "No volver a generar si el árbol ya existe",
  "dependent": "Variable dependiente",
  "independent": "Variable(s) independiente(s)",
  "weights": "Pesos de la encuesta",
  "TxtMinSplit": "División mínima",
  "minBucket": "Cubo mínimo",
  "TxtCP": "Parámetro de complejidad",
  "maxDepth": "Profundidad máxima",
  "PruneTreeChkbox": "Poda del árbol",
  "rd0": "No podar",
  "rd1": "Usar parámetro de complejidad óptimo",
  "rd2": "Especificar parámetro de complejidad",
  "TxtCPPrune": "Ingrese el parámetro de complejidad",
  "PlotCVChkbox": "Graficar validación cruzada",
  "PlotRSQRChkbox": "Graficar R-cuadrado",
  "OptvarPlots": "Gráficas",
  "OptvarPreprune": "Pre-poda",
  "OptvarPrune": "Podar árbol",  
  "help": {
    "title": "Árboles de Decisión",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>Nota</b></br>\n                Las variables dependientes pueden ser factor, ordinal, cadena, lógica y numérica</br>\n                Las variables independientes pueden ser factor, ordinal, cadena, lógica y numérica</br></br>\n                <b>Descripción</b></br>\n                Ajustar un modelo de Árbol de Partición Recursiva y Regresión\n                <br/>\n                <b>Uso</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>Argumentos</b><br/>\n                <ul>\n                <li>\n                formula: una fórmula, con una respuesta pero sin términos de interacción. Si esto es un marco de datos, se toma como el marco del modelo (ver model.frame).\n                </li>\n                <li>\n                data: un marco de datos opcional en el que interpretar las variables nombradas en la fórmula.\n                </li>\n                <li>\n                weights: pesos de caso opcionales.\n                </li>\n                <li>\n                subset: expresión opcional que dice que solo un subconjunto de las filas de los datos debe ser utilizado en el ajuste.\n                </li>\n                <li>\n                na.action: la acción predeterminada elimina todas las observaciones para las cuales y está ausente, pero mantiene aquellas en las que uno o más predictores están ausentes.\n                </li>\n                <li>\n                method: uno de \"anova\", \"poisson\", \"class\" o \"exp\". Si falta el método, la rutina intenta hacer una suposición inteligente. Si y es un objeto de supervivencia, entonces se asume method = \"exp\", si y tiene 2 columnas, entonces se asume method = \"poisson\", si y es un factor, entonces se asume method = \"class\", de lo contrario se asume method = \"anova\". Es más sabio especificar el método directamente, especialmente a medida que se pueden agregar más criterios a la función en el futuro.\n                Alternativamente, el método puede ser una lista de funciones llamadas init, split y eval. Se dan ejemplos en el archivo 'tests/usersplits.R' en las fuentes, y en los vignettes 'Funciones de División Escritas por el Usuario'.\n                </li>\n                <li>\n                model: si es lógico: ¿mantener una copia del marco del modelo en el resultado? Si el valor de entrada para el modelo es un marco de modelo (probablemente de una llamada anterior a la función rpart), entonces este marco se utiliza en lugar de construir nuevos datos.\n                </li>\n                <li>\n                x: mantener una copia de la matriz x en el resultado.\n                </li>\n                <li>\n                y: mantener una copia de la variable dependiente en el resultado. Si falta y se proporciona el modelo, esto predetermina a FALSE.\n                </li>\n                <li>\n                parms: parámetros opcionales para la función de división.<br/>\n                La división Anova no tiene parámetros.<br/>\n                La división Poisson tiene un solo parámetro, el coeficiente de variación de la distribución previa sobre las tasas. El valor predeterminado es 1.<br/>\n                La división Exponencial tiene el mismo parámetro que Poisson.<br/>\n                Para la división de clasificación, la lista puede contener cualquiera de: el vector de probabilidades previas (componente previo), la matriz de pérdidas (componente pérdida) o el índice de división (componente división). Los previos deben ser positivos y sumar 1. La matriz de pérdidas debe tener ceros en la diagonal y elementos positivos fuera de la diagonal. El índice de división puede ser gini o información. Los previos predeterminados son proporcionales a los conteos de datos, las pérdidas predeterminadas son 1, y la división predeterminada es gini.<br/>\n                </li>\n                <li>\n                control: una lista de opciones que controlan detalles del algoritmo rpart. Ver rpart.control.\n                </li>\n                <li>\n                cost: un vector de costos no negativos, uno para cada variable en el modelo. Predeterminado a uno para todas las variables. Estas son escalas que se aplican al considerar divisiones, por lo que la mejora en la división de una variable se divide por su costo al decidir qué división elegir.\n                </li>\n                <li>\n                ...: los argumentos a rpart.control también pueden especificarse en la llamada a rpart. Se verifican contra la lista de argumentos válidos.\n                </li>\n                </ul>\n                <b>Detalles</b></br>\n                Esto difiere de la función tree en S principalmente en su manejo de variables sustitutas. En la mayoría de los detalles sigue a Breiman et. al (1984) bastante de cerca. El paquete R tree proporciona una reimplementación de tree.\n                <b>Valor</b></br>\n                Un objeto de clase rpart. Ver rpart.object.</br>\n                <b>Referencias</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., y Stone, C. J. (1984) Árboles de Clasificación y Regresión. Wadsworth.</br>\n                <b>Ver También</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Ejemplos</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # de lo contrario, en algunos dispositivos el texto se recorta</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Paquete</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Ayuda</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>Descripción</b></br>\n                Control para Ajustes de Rpart. Varios parámetros que controlan aspectos del ajuste de rpart.\n                <br/>\n                <b>Uso</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argumentos</b><br/>\n                <ul>\n                <li>\n                minsplit: el número mínimo de observaciones que deben existir en un nodo para que se intente una división.\n                </li>\n                <li>\n                minbucket: el número mínimo de observaciones en cualquier nodo terminal <leaf>. Si solo se especifica uno de minbucket o minsplit, el código establece minsplit en minbucket*3 o minbucket en minsplit/3, según corresponda.\n                </li>\n                <li>\n                cp: parámetro de complejidad. Cualquier división que no disminuya la falta de ajuste general por un factor de cp no se intenta. Por ejemplo, con la división anova, esto significa que el R-cuadrado general debe aumentar en cp en cada paso. El papel principal de este parámetro es ahorrar tiempo de computación al podar divisiones que no valen la pena. Esencialmente, el usuario informa al programa que cualquier división que no mejore el ajuste en cp probablemente será podada por validación cruzada, y que por lo tanto el programa no necesita perseguirla.\n                </li>\n                <li>\n                maxcompete: el número de divisiones competidoras retenidas en la salida. Es útil saber no solo qué división fue elegida, sino qué variable llegó en segundo, tercero, etc.\n                </li>\n                <li>\n                maxsurrogate: el número de divisiones sustitutas retenidas en la salida. Si esto se establece en cero, el tiempo de cálculo se reducirá, ya que aproximadamente la mitad del tiempo computacional (aparte de la configuración) se utiliza en la búsqueda de divisiones sustitutas.\n                </li>\n                <li>\n                usesurrogate: cómo usar sustitutos en el proceso de división. 0 significa mostrar solo; una observación con un valor ausente para la regla de división primaria no se envía más abajo en el árbol. 1 significa usar sustitutos, en orden, para dividir sujetos que faltan la variable primaria; si todos los sustitutos están ausentes, la observación no se divide. Para el valor 2, si todos los sustitutos están ausentes, entonces envíe la observación en la dirección mayoritaria. Un valor de 0 corresponde a la acción de tree, y 2 a las recomendaciones de Breiman et.al (1984).\n                </li>\n                <li>\n                xval: número de validaciones cruzadas.\n                </li>\n                <li>\n                surrogatestyle: controla la selección de un mejor sustituto. Si se establece en 0 (predeterminado), el programa utiliza el número total de clasificaciones correctas para una variable sustituta potencial, si se establece en 1, utiliza el porcentaje correcto, calculado sobre los valores no ausentes del sustituto. La primera opción penaliza más severamente a los covariables con un gran número de valores ausentes.\n                </li>\n                <li>\n                maxdepth: Establece la profundidad máxima de cualquier nodo del árbol final, contando el nodo raíz como profundidad 0. Los valores mayores a 30 rpart darán resultados sin sentido en máquinas de 32 bits.\n                </li>\n                <li>\n                ...: limpiar otros argumentos.\n                </li>\n                </ul>\n                <b>Valor</b></br>\n                Una lista que contiene las opciones. \n                      "
  }
}