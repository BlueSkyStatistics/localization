{
  "title": "Convertir en facteur(s) ordonné(s)/ordinal",
  "navigation": "Vers facteur ordonné/ordinal",
  "trg": "Variables à convertir en facteur/ordinal ordonné",
  "help": {
    "title": "Convertir en facteur(s) ordonné(s)/ordinal",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>Description</b></br>\nLa fonction factor est utilisée pour une variable de facteur/ordinal ordonné. Les niveaux de facteur sont supposés être ordonnés. \n<br/>\n<b>Utilisation</b>\n<br/>\n<code>\nfactor(x = character(),  ordered = TRUE)\n</code> <br/>\n<b>Arguments</b><br/>\n<ul>\n<li>\nx : un vecteur de données, prenant généralement un petit nombre de valeurs distinctes.\n</li>\n<li>\nniveaux : un vecteur optionnel des valeurs (sous forme de chaînes de caractères) que x pourrait avoir prises. La valeur par défaut est l'ensemble unique de valeurs prises par as.character(x), triées dans l'ordre croissant de x. Notez que cet ensemble peut être spécifié comme étant plus petit que sort(unique(x)).\n</li>\n<li>\nétiquettes : soit un vecteur de caractères optionnel d'étiquettes pour les niveaux (dans le même ordre que les niveaux après avoir supprimé ceux dans exclure), soit une chaîne de caractères de longueur 1.\n</li>\n<li>\nexclure : un vecteur de valeurs à exclure lors de la formation de l'ensemble des niveaux. Cela doit être du même type que x, et sera converti si nécessaire.\n</li>\n<li>\nordonné : un indicateur logique pour déterminer si les niveaux doivent être considérés comme ordonnés (dans l'ordre donné).\n</li>\n<li>\nnmax : une limite supérieure sur le nombre de niveaux ; voir « Détails ».\n</li>\n<li>\n...(dans ordered(.)) : n'importe lequel des éléments ci-dessus, à l'exception de ordonné lui-même.\n</li>\n<li>\ns'il y a : (ajouter un niveau NA uniquement s'il est utilisé, c'est-à-dire si any(is.na(x)).\n</li>\n</ul>\n<b>Détails</b></br>\nLe type du vecteur x n'est pas restreint ; il doit seulement avoir une méthode as.character et être triable (par sort.list).<br/>\nLes facteurs ordonnés diffèrent des facteurs uniquement par leur classe, mais les méthodes et les fonctions d'ajustement de modèle traitent les deux classes de manière assez différente.<br/>\nL'encodage du vecteur se fait comme suit. D'abord, toutes les valeurs dans exclure sont supprimées des niveaux. Si x[i] est égal à niveaux[j], alors l'élément i du résultat est j. Si aucune correspondance n'est trouvée pour x[i] dans niveaux (ce qui se produira pour les valeurs exclues), alors l'élément i du résultat est défini sur NA.<br/>\nNormalement, les « niveaux » utilisés comme attribut du résultat sont l'ensemble réduit de niveaux après avoir supprimé ceux dans exclure, mais cela peut être modifié en fournissant des étiquettes. Cela devrait être soit un ensemble de nouvelles étiquettes pour les niveaux, soit une chaîne de caractères, auquel cas les niveaux sont cette chaîne de caractères avec un numéro de séquence ajouté.<br/>\nfactor(x, exclure = NULL) appliqué à un facteur est une opération nulle à moins qu'il n'y ait des niveaux non utilisés : dans ce cas, un facteur avec l'ensemble de niveaux réduit est retourné. Si exclure est utilisé, cela devrait également être un facteur avec le même ensemble de niveaux que x ou un ensemble de codes pour les niveaux à exclure.<br/>\nLes codes d'un facteur peuvent contenir NA. Pour un x numérique, définissez exclure = NULL pour faire de NA un niveau supplémentaire (imprimé comme <NA>) ; par défaut, c'est le dernier niveau.<br/>\nSi NA est un niveau, la façon de définir un code comme manquant (par opposition au code du niveau manquant) est d'utiliser is.na sur le côté gauche d'une affectation (comme dans is.na(f)[i] <- TRUE ; l'indexation à l'intérieur de is.na ne fonctionne pas). Dans ces circonstances, les valeurs manquantes sont actuellement imprimées comme <NA>, c'est-à-dire identiques aux entrées du niveau NA.<br/>\nis.factor est générique : vous pouvez écrire des méthodes pour gérer des classes spécifiques d'objets, voir InternalMethods.<br/>\nLorsque niveaux n'est pas fourni, unique est appelé. Étant donné que les facteurs ont généralement un nombre assez petit de niveaux, pour de grands vecteurs x, il est utile de fournir nmax comme limite supérieure sur le nombre de valeurs uniques.<br/>\n<b>Valeur</b><br/>\nfactor retourne un objet de classe \"facteur\" qui a un ensemble de codes entiers de la longueur de x avec un attribut \"niveaux\" de mode caractère et unique (!anyDuplicated(.)) entrées. Si l'argument ordonné est vrai (ou ordered() est utilisé), le résultat a la classe c(\"ordonné\", \"facteur\").<br/>\nAppliquer factor à un facteur ordonné ou non ordonné retourne un facteur (du même type) avec juste les niveaux qui se produisent : voir aussi [.factor pour une manière plus transparente d'y parvenir.\nis.factor retourne TRUE ou FALSE selon que son argument est de type facteur ou non. En conséquence, is.ordered retourne TRUE lorsque son argument est un facteur ordonné et FALSE sinon.<br/>\nas.factor convertit son argument en facteur. C'est une forme abrégée de factor.<br/>\nas.ordered(x) retourne x si cela est ordonné, et ordered(x) sinon.<br/>\naddNA modifie un facteur en transformant NA en un niveau supplémentaire (de sorte que les valeurs NA soient comptées dans les tableaux, par exemple).<br/>\n<b>Paquet</b></br>\nbase</br>\n<b>Aide</b></br>\nhelp(factor, package =base)\n"
  }
}