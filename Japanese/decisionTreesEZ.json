{
  "title": "決定木",
  "navigation": "決定木",
  "TxtTreeName": "モデル名を入力",
  "TreeGenChkbox": "ツリーが既に存在する場合は再生成しない",
  "dependent": "従属変数",
  "independent": "独立変数",
  "weights": "調査ウェイト",
  "TxtMinSplit": "最小分割",
  "minBucket": "最小バケット",
  "TxtCP": "複雑さパラメータ",
  "maxDepth": "最大深さ",
  "PruneTreeChkbox": "ツリーを剪定する",
  "rd0": "剪定しない",
  "rd1": "最適な複雑さパラメータを使用する",
  "rd2": "複雑さパラメータを指定する",
  "TxtCPPrune": "複雑さパラメータを入力",
  "PlotCVChkbox": "交差検証をプロットする",
  "PlotRSQRChkbox": "R二乗をプロットする",
  "OptvarPlots": "グラフ",
  "OptvarPreprune": "事前剪定",
  "OptvarPrune": "木を剪定する",  
  "help": {
    "title": "決定木",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>注意</b></br>\n                従属変数は因子、順序、文字列、論理、数値であることができます</br>\n                独立変数は因子、順序、文字列、論理、数値であることができます</br></br>\n                <b>説明</b></br>\n                再帰的分割および回帰木モデルを適合させます\n                <br/>\n                <b>使用法</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>引数</b><br/>\n                <ul>\n                <li>\n                formula: 応答があるが相互作用項がない式。データフレームの場合は、モデルフレームとして使用されます（model.frameを参照）。\n                </li>\n                <li>\n                data: 式で指定された変数を解釈するためのオプションのデータフレーム。\n                </li>\n                <li>\n                weights: オプションのケースウェイト。\n                </li>\n                <li>\n                subset: フィットに使用するデータの行のサブセットを指定するオプションの式。\n                </li>\n                <li>\n                na.action: デフォルトのアクションは、yが欠損しているすべての観測を削除しますが、1つ以上の予測子が欠損している観測は保持します。\n                </li>\n                <li>\n                method: \"anova\"、\"poisson\"、\"class\"、または\"exp\"のいずれか。メソッドが欠落している場合、ルーチンは知的な推測を試みます。yが生存オブジェクトの場合、method = \"exp\"が仮定され、yが2列の場合はmethod = \"poisson\"が仮定され、yが因子の場合はmethod = \"class\"が仮定され、それ以外の場合はmethod = \"anova\"が仮定されます。特に、将来的に関数に追加される可能性のある基準が増えるため、メソッドを直接指定することが最も賢明です。\n                代わりに、メソッドはinit、split、evalという名前の関数のリストであることもできます。例は、ソース内のファイル「tests/usersplits.R」と、ビネット「ユーザー作成の分割関数」に示されています。\n                </li>\n                <li>\n                model: 論理的な場合: 結果にモデルフレームのコピーを保持しますか？モデルの入力値がモデルフレーム（以前のrpart関数の呼び出しからのものと思われる）である場合、このフレームが使用され、新しいデータが構築されることはありません。\n                </li>\n                <li>\n                x: 結果にx行列のコピーを保持します。\n                </li>\n                <li>\n                y: 結果に従属変数のコピーを保持します。欠落していてモデルが提供されている場合、これはデフォルトでFALSEになります。\n                </li>\n                <li>\n                parms: 分割関数のオプションのパラメータ。<br/>\n                Anova分割にはパラメータはありません。<br/>\n                Poisson分割には、率の事前分布の変動係数という単一のパラメータがあります。デフォルト値は1です。<br/>\n                指数分割はPoissonと同じパラメータを持ちます。<br/>\n                分類分割の場合、リストには次のいずれかが含まれる可能性があります: 事前確率のベクトル（コンポーネント事前）、損失行列（コンポーネント損失）、または分割インデックス（コンポーネント分割）。事前確率は正であり、合計は1でなければなりません。損失行列は対角にゼロを持ち、オフ対角要素は正でなければなりません。分割インデックスはginiまたは情報である可能性があります。デフォルトの事前確率はデータカウントに比例し、損失はデフォルトで1、分割はデフォルトでginiです。<br/>\n                </li>\n                <li>\n                control: rpartアルゴリズムの詳細を制御するオプションのリスト。rpart.controlを参照してください。\n                </li>\n                <li>\n                cost: モデル内の各変数に対する非負のコストのベクトル。すべての変数に対してデフォルトは1です。これらは分割を考慮する際に適用されるスケーリングであり、変数での分割の改善は、どの分割を選択するかを決定する際にそのコストで割られます。\n                </li>\n                <li>\n                ...: rpart.controlに対する引数もrpartへの呼び出しで指定できます。有効な引数のリストに対してチェックされます。\n                </li>\n                </ul>\n                <b>詳細</b></br>\n                これは、主に代理変数の取り扱いにおいて、Sのtree関数とは異なります。ほとんどの詳細はBreiman et. al (1984)に非常に近いです。Rパッケージtreeはtreeの再実装を提供します。\n                <b>値</b></br>\n                rpartクラスのオブジェクト。rpart.objectを参照してください。</br>\n                <b>参考文献</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., and Stone, C. J. (1984) 分類と回帰の木。Wadsworth。</br>\n                <b>参照</b></br>\n                rpart.control、rpart.object、summary.rpart、print.rpart</br>\n                <b>例</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # さもなければ、いくつかのデバイスでテキストがクリップされます</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>パッケージ</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>ヘルプ</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>説明</b></br>\n                Rpartフィッティングの制御。rpartフィットの側面を制御するさまざまなパラメータ。\n                <br/>\n                <b>使用法</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>引数</b><br/>\n                <ul>\n                <li>\n                minsplit: 分割を試みるためにノードに存在しなければならない最小観測数。\n                </li>\n                <li>\n                minbucket: 任意の端末<leaf>ノードにおける観測の最小数。minbucketまたはminsplitのいずれかのみが指定されている場合、コードはminsplitをminbucket*3またはminbucketをminsplit/3のいずれかに設定します。\n                </li>\n                <li>\n                cp: 複雑さパラメータ。全体の適合度をcpの因子で減少させない分割は試みられません。たとえば、anova分割の場合、これは全体のR二乗が各ステップでcpによって増加しなければならないことを意味します。このパラメータの主な役割は、明らかに価値のない分割を剪定することによって計算時間を節約することです。基本的に、ユーザーはプログラムに、適合度をcpで改善しない分割は、交差検証によって剪定される可能性が高いことを通知し、したがってプログラムはそれを追求する必要がないことを通知します。\n                </li>\n                <li>\n                maxcompete: 出力に保持される競合分割の数。どの分割が選択されたかだけでなく、どの変数が2位、3位、などであったかを知るのに役立ちます。\n                </li>\n                <li>\n                maxsurrogate: 出力に保持される代理分割の数。これがゼロに設定されている場合、計算時間は短縮されます。なぜなら、約半分の計算時間（セットアップ以外）は代理分割の検索に使用されるからです。\n                </li>\n                <li>\n                usesurrogate: 分割プロセスで代理をどのように使用するか。0は表示のみを意味します。主要な分割ルールの欠損値を持つ観測は、ツリーの下に送信されません。1は、主要な変数が欠損している被験者を分割するために、順番に代理を使用することを意味します。すべての代理が欠損している場合、観測は分割されません。値2の場合、すべての代理が欠損している場合、観測は多数の方向に送信されます。値0はtreeの動作に対応し、2はBreiman et.al (1984)の推奨に対応します。\n                </li>\n                <li>\n                xval: 交差検証の数。\n                </li>\n                <li>\n                surrogatestyle: 最良の代理の選択を制御します。0（デフォルト）に設定されている場合、プログラムは潜在的な代理変数の正しい分類の総数を使用します。1に設定されている場合、代理の非欠損値に対して計算された正しい割合を使用します。最初のオプションは、欠損値の多い共変量に対してより厳しく罰します。\n                </li>\n                <li>\n                maxdepth: 最終ツリーの任意のノードの最大深さを設定します。ルートノードは深さ0としてカウントされます。30を超える値は、32ビットマシンで無意味な結果を与えます。\n                </li>\n                <li>\n                ...: 他の引数を処理します。\n                </li>\n                </ul>\n                <b>値</b></br>\n                オプションを含むリスト。 \n                      "
  }
}