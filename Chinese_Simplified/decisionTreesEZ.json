{
  "title": "决策树",
  "navigation": "决策树",
  "TxtTreeName": "输入模型名称",
  "TreeGenChkbox": "如果树已存在，则不重新生成",
  "dependent": "因变量",
  "independent": "自变量",
  "weights": "调查权重",
  "TxtMinSplit": "最小分裂",
  "minBucket": "最小桶",
  "TxtCP": "复杂度参数",
  "maxDepth": "最大深度",
  "PruneTreeChkbox": "修剪树",
  "rd0": "不修剪",
  "rd1": "使用最佳复杂度参数",
  "rd2": "指定复杂度参数",
  "TxtCPPrune": "输入复杂度参数",
  "PlotCVChkbox": "绘制交叉验证",
  "PlotRSQRChkbox": "绘制R平方",
  "OptvarPlots": "图表",
  "OptvarPreprune": "预剪枝",
  "OptvarPrune": "剪枝树",  
  "help": {
    "title": "决策树",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>注意</b></br>\n                因变量可以是因子、序数、字符串、逻辑和数值</br>\n                自变量可以是因子、序数、字符串、逻辑和数值</br></br>\n                <b>描述</b></br>\n                拟合递归分区和回归树模型\n                <br/>\n                <b>用法</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>参数</b><br/>\n                <ul>\n                <li>\n                formula: 一个公式，包含响应但没有交互项。如果这是一个数据框，则作为模型框架（见model.frame）使用。\n                </li>\n                <li>\n                data: 一个可选的数据框，用于解释公式中命名的变量。\n                </li>\n                <li>\n                weights: 可选的案例权重。\n                </li>\n                <li>\n                subset: 可选的表达式，表示仅使用数据的子集进行拟合。\n                </li>\n                <li>\n                na.action: 默认操作删除所有y缺失的观察，但保留一个或多个预测变量缺失的观察。\n                </li>\n                <li>\n                method: \"anova\"、\"poisson\"、\"class\"或\"exp\"之一。如果缺少方法，则例程尝试进行智能猜测。如果y是生存对象，则假定method = \"exp\"，如果y有2列，则假定method = \"poisson\"，如果y是因子，则假定method = \"class\"，否则假定method = \"anova\"。最好直接指定方法，特别是因为将来可能会向函数添加更多标准。\n                或者，方法可以是名为init、split和eval的函数列表。示例在源文件‘tests/usersplits.R’中给出，在小册子‘用户编写的拆分函数’中也有。\n                </li>\n                <li>\n                model: 如果是逻辑值：在结果中保留模型框架的副本？如果模型的输入值是模型框架（可能来自对rpart函数的早期调用），则使用该框架而不是构造新数据。\n                </li>\n                <li>\n                x: 在结果中保留x矩阵的副本。\n                </li>\n                <li>\n                y: 在结果中保留因变量的副本。如果缺失且提供了模型，则默认为FALSE。\n                </li>\n                <li>\n                parms: 可选的拆分函数参数。<br/>\n                Anova拆分没有参数。<br/>\n                Poisson拆分有一个参数，即先前分布率的变异系数。默认值为1。<br/>\n                指数拆分与Poisson相同的参数。<br/>\n                对于分类拆分，列表可以包含以下任意内容：先验概率向量（组件先验）、损失矩阵（组件损失）或拆分指数（组件拆分）。先验必须为正且总和为1。损失矩阵的对角线必须为零，非对角线元素必须为正。拆分指数可以是gini或信息。默认先验与数据计数成比例，损失默认值为1，拆分默认值为gini。<br/>\n                </li>\n                <li>\n                control: 控制rpart算法细节的选项列表。请参见rpart.control。\n                </li>\n                <li>\n                cost: 一个非负成本向量，每个变量一个。默认值为所有变量的1。这些是在考虑拆分时应用的缩放，因此在决定选择哪个拆分时，拆分变量的改进除以其成本。\n                </li>\n                <li>\n                ...: 还可以在对rpart的调用中指定rpart.control的参数。它们会与有效参数列表进行检查。\n                </li>\n                </ul>\n                <b>细节</b></br>\n                这与S中的tree函数主要在于对替代变量的处理。在大多数细节上，它与Breiman等（1984）非常接近。R包tree提供了tree的重新实现。\n                <b>值</b></br>\n                一个rpart类的对象。请参见rpart.object。</br>\n                <b>参考文献</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., 和 Stone, C. J. (1984) 分类与回归树。Wadsworth。</br>\n                <b>另请参见</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>示例</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # 否则在某些设备上文本会被剪切</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>包</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>帮助</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>描述</b></br>\n                控制Rpart拟合的参数。各种控制rpart拟合方面的参数。\n                <br/>\n                <b>用法</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>参数</b><br/>\n                <ul>\n                <li>\n                minsplit: 在节点中必须存在的最小观察数，以便尝试拆分。\n                </li>\n                <li>\n                minbucket: 任何终端<leaf>节点中的最小观察数。如果仅指定minbucket或minsplit之一，则代码将相应地将minsplit设置为minbucket*3或minbucket设置为minsplit/3。\n                </li>\n                <li>\n                cp: 复杂度参数。任何不减少整体拟合缺失的拆分因子都不会被尝试。例如，对于anova拆分，这意味着整体R平方必须在每一步增加cp。此参数的主要作用是通过修剪掉明显不值得的拆分来节省计算时间。用户基本上告知程序，任何不改善拟合的拆分都可能会通过交叉验证被修剪，因此程序无需追求它。\n                </li>\n                <li>\n                maxcompete: 输出中保留的竞争拆分的数量。了解不仅选择了哪个拆分，还了解哪个变量排在第二、第三等是有用的。\n                </li>\n                <li>\n                maxsurrogate: 输出中保留的替代拆分的数量。如果将其设置为零，则计算时间将减少，因为大约一半的计算时间（除了设置）用于搜索替代拆分。\n                </li>\n                <li>\n                usesurrogate: 在拆分过程中如何使用替代。0表示仅显示；具有主要拆分规则缺失值的观察不会进一步向下树。1表示使用替代，按顺序拆分缺失主要变量的对象；如果所有替代都缺失，则不拆分观察。对于值2，如果所有替代都缺失，则将观察发送到大多数方向。值0对应于tree的操作，值2对应于Breiman等（1984）的建议。\n                </li>\n                <li>\n                xval: 交叉验证的数量。\n                </li>\n                <li>\n                surrogatestyle: 控制最佳替代的选择。如果设置为0（默认），程序使用潜在替代变量的正确分类总数，如果设置为1，则使用在替代的非缺失值上计算的正确百分比。第一个选项更严厉地惩罚缺失值较多的协变量。\n                </li>\n                <li>\n                maxdepth: 设置最终树的任何节点的最大深度，根节点计为深度0。大于30的值在32位机器上会产生无意义的结果。\n                </li>\n                <li>\n                ...: 处理其他参数。\n                </li>\n                </ul>\n                <b>值</b></br>\n                包含选项的列表。 \n                      "
  }
}