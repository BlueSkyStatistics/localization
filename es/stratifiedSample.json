{
  "title": "División Estratificada",
  "navigation": "División Estratificada",
  "traindataset": "Ingrese el nombre del conjunto de datos de entrenamiento",
  "testdataset": "Ingrese el nombre del conjunto de datos de prueba",
  "split": "Ingrese el porcentaje de división",
  "seed": "Establecer semilla",
  "dependent": "Variable para construir muestras estratificadas",
  "help": {
    "title": "División Estratificada",
    "r_help": "help(createDataPartition, package=\"caret\")",
    "body": "\n<b>Descripción</b></br>\nSe crea una serie de particiones de prueba/entrenamiento utilizando createDataPartition, mientras que createResample crea una o más muestras bootstrap. createFolds divide los datos en k grupos, mientras que createTimeSlices crea una división de validación cruzada para datos de series temporales. groupKFold divide los datos en función de un factor de agrupación.\n<br/>\n<b>Uso</b>\n<br/>\n<code> \ncreateDataPartition(y, times = 1, p = 0.5, list = TRUE, groups = min(5,length(y)))<br/>\ncreateFolds(y, k = 10, list = TRUE, returnTrain = FALSE)<br/>\ncreateTimeSlices(y, initialWindow, horizon = 1, fixedWindow = TRUE,skip = 0)<br/>\ngroupKFold(group, k = length(unique(group)))<br/>\n</code> <br/>\n<b>Argumentos</b><br/>\n<ul>\n<li>\ny: un vector de resultados. Para createTimeSlices, estos deben estar en orden cronológico.\n</li>\n<li>\ntimes: el número de particiones a crear\n</li>\n<li>\np: el porcentaje de datos que va a entrenamiento\n</li>\n<li>\nlist: lógico - ¿deben los resultados estar en una lista (TRUE) o en una matriz con el número de filas igual a floor(p * length(y)) y columnas times?\n</li>\n<li>\ngroups: para y numérico, el número de rupturas en los cuantiles (ver más abajo)\n</li>\n<li>\nk: un entero para el número de pliegues.\n</li>\n<li>\nreturnTrain: un lógico. Cuando es verdadero, los valores devueltos son las posiciones de muestra correspondientes a los datos utilizados durante el entrenamiento. Este argumento solo funciona en conjunto con list = TRUE\n</li>\n<li>\ninitialWindow: El número inicial de valores consecutivos en cada muestra de conjunto de entrenamiento\n</li>\n<li>\nhorizon: el número de valores consecutivos en la muestra de conjunto de prueba\n</li>\n<li>\nfixedWindow: lógico, si es FALSE, todas las muestras de entrenamiento comienzan en 1\n</li>\n<li>\nskip: entero, cuántos (si los hay) re-muestreos omitir para reducir la cantidad total\n</li>\n<li>\ngroup: un vector de grupos cuya longitud coincide con el número de filas en el conjunto de datos general.\n</li>\n</ul>\n<b>Detalles</b></br>\nPara muestras bootstrap, se utiliza un muestreo aleatorio simple.\nPara otras divisiones de datos, el muestreo aleatorio se realiza dentro de los niveles de y cuando y es un factor en un intento de equilibrar las distribuciones de clase dentro de las divisiones.</br>\nPara y numérico, la muestra se divide en secciones de grupos basadas en percentiles y el muestreo se realiza dentro de estos subgrupos. Para createDataPartition, el número de percentiles se establece a través del argumento groups. Para createFolds y createMultiFolds, el número de grupos se establece dinámicamente en función del tamaño de la muestra y k. Para tamaños de muestra más pequeños, estas dos funciones pueden no realizar una división estratificada y, como máximo, dividir los datos en cuartiles.</br>\nAdemás, para createDataPartition, tamaños de clase muy pequeños (<= 3) pueden no aparecer tanto en los datos de entrenamiento como en los de prueba.</br>\nPara múltiples validaciones cruzadas k-fold, se crean pliegues completamente independientes. Los nombres de los objetos de lista denotarán la pertenencia al pliegue utilizando el patrón \"Foldi.Repj\", lo que significa la i-ésima sección (de k) del j-ésimo conjunto de validación cruzada (de times). Tenga en cuenta que esta función llama a createFolds con list = TRUE y returnTrain = TRUE.</br>\nHyndman y Athanasopoulos (2013) discuten técnicas de origen de pronóstico rodante que mueven los conjuntos de entrenamiento y prueba en el tiempo. createTimeSlices puede crear los índices para este tipo de división.</br>\nPara la validación cruzada k-fold de grupo, los datos se dividen de tal manera que ningún grupo esté contenido tanto en los conjuntos de modelado como de retención. Uno o más grupos podrían quedar fuera, dependiendo del valor de k.</br>\n<b>Valor</b><br/>\nUna lista o matriz de enteros de posición de fila correspondientes a los datos de entrenamiento. Para createTimeSlices, las submuestras se nombran por el índice final de cada submuestra de entrenamiento.</br>\n<b>Paquete</b></br>\ncaret</br>\nklaR</br>\n<b>Ayuda</b></br>\nhelp(createDataPartition, package=\"caret\")\n        "
  }
}