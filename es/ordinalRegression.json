{
  "title": "Regresión Ordinal",
  "navigation": "Ordinal",
  "label1": "Método de prueba",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Ingrese el nombre del modelo",
  "dependent": "Variable dependiente",
  "formula": "Variable(s) independiente(s)",
  "generateplotchk": "Graficar residuos vs ajustados, Q-Q normal, ubicación de escala y residuos vs apalancamiento",
  "weights": "Especificar una variable con pesos",
  "help": {
    "title": "Ordinal",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Descripción</b></br>\n            Ajusta un modelo de regresión logística o probit a una respuesta de factor ordenado. El caso logístico predeterminado es la regresión logística de probabilidades proporcionales, después de lo cual se nombra la función.\n            <br/>\n            <b>Uso</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argumentos</b><br/>\n            <ul>\n            <li>\n            formula: una expresión de fórmula como para modelos de regresión, de la forma respuesta ~ predictores. La respuesta debe ser un factor (preferiblemente un factor ordenado), que se interpretará como una respuesta ordinal, con niveles ordenados como en el factor. El modelo debe tener una intersección: los intentos de eliminar uno generarán una advertencia y serán ignorados. Se puede usar un offset. Consulte la documentación de la fórmula para otros detalles.\n            </li>\n            <li>\n            data: un marco de datos opcional en el que interpretar las variables que aparecen en la fórmula.\n            </li>\n            <li>\n            weights: pesos de caso opcionales en el ajuste. Por defecto es 1.\n            </li>\n            <li>\n            start: valores iniciales para los parámetros. Esto está en el formato c(coefficients, zeta): consulte la sección de Valores.\n            </li>\n            <li>\n            ... argumentos adicionales que se pasarán a optim, a menudo un argumento de control.\n            </li>\n            <li>\n            subset: expresión que indica qué subconjunto de las filas de los datos debe usarse en el ajuste. Todas las observaciones se incluyen por defecto.\n            </li>\n            <li>\n            na.action: una función para filtrar datos faltantes.\n            </li>\n            <li>\n            contrasts: una lista de contrastes que se utilizarán para algunos o todos los factores que aparecen como variables en la fórmula del modelo.\n            </li>\n            <li>\n            Hess: lógico para si se debe devolver el Hessiano (la matriz de información observada). Use esto si tiene la intención de llamar a resumen o vcov en el ajuste.\n            </li>\n            <li>\n            model: lógico para si se debe devolver la matriz del modelo.\n            </li>\n            <li>\n            method: logístico o probit o (complementario) log-log o cauchit (correspondiente a una variable latente de Cauchy).\n            </li>\n            </ul>\n            <b>Detalles</b></br>\n            Este modelo es lo que Agresti (2002) llama un modelo de enlace acumulativo. La interpretación básica es como una versión coarsened de una variable latente Y_i que tiene una distribución logística o normal o de valor extremo o de Cauchy con un parámetro de escala uno y un modelo lineal para la media. El factor ordenado que se observa es en qué bin cae Y_i con puntos de ruptura\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Esto conduce al modelo</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            con logit reemplazado por probit para una variable latente normal, y eta siendo el predictor lineal, una función lineal de las variables explicativas (sin intersección). Tenga en cuenta que es bastante común que otro software use el signo opuesto para eta (y por lo tanto los coeficientes beta).</br>\n            En el caso logístico, el lado izquierdo de la última visualización son las probabilidades logarítmicas de la categoría k o menos, y dado que estas son probabilidades logarítmicas que difieren solo por una constante para diferentes k, las probabilidades son proporcionales. De ahí el término regresión logística de probabilidades proporcionales.</br>\n            Los enlaces log-log y log-log complementarios son las funciones crecientes F^-1(p) = -log(-log(p)) y F^-1(p) = log(-log(1-p)); algunos llaman al primero el enlace 'log-log negativo'. Estos corresponden a una variable latente con la distribución de valor extremo para el máximo y el mínimo respectivamente.</br>\n            Un modelo de riesgos proporcionales para tiempos de supervivencia agrupados se puede obtener utilizando el enlace log-log complementario con agrupación ordenada por tiempos crecientes.</br>\n            predict, summary, vcov, anova, model.frame y un método extractAIC para usar con stepAIC (y step). También hay métodos de perfil y confint.</br>\n            <b>Valor</b><br/>\n            Un objeto de clase \"polr\". Esto tiene componentes\n            <li>\n            coefficients: los coeficientes del predictor lineal, que no tiene intersección.\n            </li>\n            <li>\n            zeta: las intersecciones para los límites de clase.\n            </li>\n            <li>\n            deviance: la desviación residual.\n            </li>\n            <li>\n            fitted.values: una matriz, con una columna para cada nivel de la respuesta.\n            </li>\n            <li>\n            lev: los nombres de los niveles de respuesta.\n            </li>\n            <li>\n            terms: la estructura de términos que describe el modelo.\n            </li>\n            <li>\n            df.residual: el número de grados de libertad residuales, calculado utilizando los pesos.\n            </li>\n            <li>\n            edf: el número (efectivo) de grados de libertad utilizados por el modelo\n            </li>\n            <li>\n            n, nobs: el número (efectivo) de observaciones, calculado utilizando los pesos. (nobs es para uso por stepAIC.\n            </li>\n            <li>\n            call: la llamada coincidente.\n            </li>\n            <li>\n            method: el método coincidente utilizado.\n            </li>\n            <li>\n            convergence: el código de convergencia devuelto por optim.\n            </li>\n            <li>\n            niter: el número de evaluaciones de función y gradiente utilizadas por optim.\n            </li>\n            <li>\n            lp: el predictor lineal (incluyendo cualquier offset).</li>\n            <li>\n            Hessian: (si Hess es verdadero). Tenga en cuenta que esta es una aproximación numérica derivada del proceso de optimización.\n            </li>\n            <li>\n            model:(si el modelo es verdadero).\n            </li>\n            <li>\n            Nota</br>\n            El método vcov utiliza el Hessiano aproximado: para resultados confiables, la matriz del modelo debe estar razonablemente escalada con todas las columnas teniendo un rango del orden de uno.</br>\n            Antes de la versión 7.3-32, el método = \"cloglog\" confusamente daba el enlace log-log, asumiendo implícitamente que el primer nivel de respuesta era el 'mejor'.</br>\n            <br/>\n            <b>Ejemplos</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## ajuste ligeramente peor de<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## aunque no es realmente apropiado, se puede ajustar<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Paquete</b></br>\n            MASS</br>\n            <b>Ayuda</b></br>\n            Para ayuda detallada, haga clic en el ícono de R en la parte superior derecha de este diálogo o ejecute el siguiente comando help(polr, package =MASS) creando un bloque de código R haciendo clic en + en la ventana de salida\t\t\t"
  }
}