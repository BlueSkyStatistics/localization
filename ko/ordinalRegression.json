{
  "title": "서수 회귀",
  "navigation": "서수",
  "label1": "테스트 방법",
  "logit": "로짓",
  "probit": "프로빗",
  "modelname": "모델 이름 입력",
  "dependent": "종속 변수",
  "formula": "독립 변수(들)",
  "generateplotchk": "잔차 대 적합도, 정규 Q-Q, 스케일-위치 및 잔차 대 레버리지 플롯 생성",
  "weights": "가중치가 있는 변수를 지정하십시오",
  "help": {
    "title": "서수",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>설명</b></br>\n            순서형 반응에 로지스틱 또는 프로빗 회귀 모델을 적합합니다. 기본 로지스틱 경우는 비례 오즈 로지스틱 회귀이며, 함수 이름이 붙여진 것입니다.\n            <br/>\n            <b>사용법</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>인수</b><br/>\n            <ul>\n            <li>\n            formula: 회귀 모델을 위한 수식 표현으로, 형태는 response ~ predictors입니다. 반응은 팩터(바람직하게는 순서형 팩터)여야 하며, 이는 순서형 반응으로 해석됩니다. 모델은 절편을 가져야 합니다: 하나를 제거하려고 하면 경고가 발생하고 무시됩니다. 오프셋을 사용할 수 있습니다. 수식의 문서에서 다른 세부정보를 참조하십시오.\n            </li>\n            <li>\n            data: 수식에서 발생하는 변수를 해석할 선택적 데이터 프레임입니다.\n            </li>\n            <li>\n            weights: 적합 시 선택적 사례 가중치입니다. 기본값은 1입니다.\n            </li>\n            <li>\n            start: 매개변수의 초기 값입니다. 이는 c(계수, 제타) 형식입니다: 값 섹션을 참조하십시오.\n            </li>\n            <li>\n            ... optim에 전달할 추가 인수, 가장 자주 제어 인수입니다.\n            </li>\n            <li>\n            subset: 데이터의 행 중 어떤 부분 집합이 적합에 사용되어야 하는지를 나타내는 표현식입니다. 기본적으로 모든 관측치가 포함됩니다.\n            </li>\n            <li>\n            na.action: 결측 데이터를 필터링하는 함수입니다.\n            </li>\n            <li>\n            contrasts: 모델 수식에서 변수로 나타나는 일부 또는 모든 팩터에 대해 사용할 대비 목록입니다.\n            </li>\n            <li>\n            Hess: 헤시안(관측 정보 행렬)을 반환해야 하는지 여부에 대한 논리값입니다. 적합에 대해 summary 또는 vcov를 호출할 계획이라면 이를 사용하십시오.\n            </li>\n            <li>\n            model: 모델 행렬을 반환해야 하는지 여부에 대한 논리값입니다.\n            </li>\n            <li>\n            method: 로지스틱 또는 프로빗 또는 (보완) 로그-로그 또는 코시트(코시 잠재 변수에 해당)입니다.\n            </li>\n            </ul>\n            <b>세부정보</b></br>\n            이 모델은 Agresti(2002)가 누적 링크 모델이라고 부르는 것입니다. 기본 해석은 로지스틱 또는 정규 또는 극값 또는 코시 분포를 가진 잠재 변수 Y_i의 거칠게 표현된 버전으로, 평균에 대한 선형 모델을 가지고 있습니다. 관측된 순서형 팩터는 Y_i가 떨어지는 빈을 나타내며, 경계점은\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            이로 인해 모델이 생성됩니다</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            여기서 logit은 정규 잠재 변수에 대해 프로빗으로 대체되며, eta는 선형 예측기이며, 설명 변수의 선형 함수입니다(절편 없음). 다른 소프트웨어에서 eta(따라서 계수 beta)의 반대 부호를 사용하는 것이 일반적입니다.</br>\n            로지스틱 경우, 마지막 표시의 왼쪽은 k 이하의 범주에 대한 로그 오즈이며, 이러한 오즈는 k에 따라 상수만 다르므로 비례합니다. 따라서 비례 오즈 로지스틱 회귀라는 용어가 붙습니다.</br>\n            로그-로그 및 보완 로그-로그 링크는 증가 함수 F^-1(p) = -log(-log(p)) 및 F^-1(p) = log(-log(1-p))입니다; 일부는 첫 번째를 '부정 로그-로그' 링크라고 부릅니다. 이는 최대 및 최소에 대한 극값 분포를 가진 잠재 변수에 해당합니다.</br>\n            그룹화된 생존 시간에 대한 비례 위험 모델은 증가하는 시간에 따라 그룹화된 보완 로그-로그 링크를 사용하여 얻을 수 있습니다.</br>\n            predict, summary, vcov, anova, model.frame 및 stepAIC(및 step)와 함께 사용할 extractAIC 메서드가 있습니다. 또한 프로파일 및 confint 메서드도 있습니다.</br>\n            <b>값</b><br/>\n            \"polr\" 클래스의 객체입니다. 이 객체는 다음 구성 요소를 가집니다\n            <li>\n            coefficients: 절편이 없는 선형 예측기의 계수입니다.\n            </li>\n            <li>\n            zeta: 클래스 경계에 대한 절편입니다.\n            </li>\n            <li>\n            deviance: 잔차 편차입니다.\n            </li>\n            <li>\n            fitted.values: 반응의 각 수준에 대한 열이 있는 행렬입니다.\n            </li>\n            <li>\n            lev: 반응 수준의 이름입니다.\n            </li>\n            <li>\n            terms: 모델을 설명하는 항 구조입니다.\n            </li>\n            <li>\n            df.residual: 가중치를 사용하여 계산된 잔차 자유도 수입니다.\n            </li>\n            <li>\n            edf: 모델에서 사용된 (유효) 자유도 수입니다\n            </li>\n            <li>\n            n, nobs: 가중치를 사용하여 계산된 (유효) 관측치 수입니다. (nobs는 stepAIC에서 사용됩니다.\n            </li>\n            <li>\n            call: 일치하는 호출입니다.\n            </li>\n            <li>\n            method: 사용된 일치하는 방법입니다.\n            </li>\n            <li>\n            convergence: optim에 의해 반환된 수렴 코드입니다.\n            </li>\n            <li>\n            niter: optim에 의해 사용된 함수 및 기울기 평가 수입니다.\n            </li>\n            <li>\n            lp: 선형 예측기(모든 오프셋 포함).</li>\n            <li>\n            Hessian: (Hess가 true인 경우). 이는 최적화 과정에서 파생된 수치 근사값입니다.\n            </li>\n            <li>\n            model:(모델이 true인 경우).\n            </li>\n            <li>\n            참고</br>\n            vcov 메서드는 근사 헤시안을 사용합니다: 신뢰할 수 있는 결과를 위해 모델 행렬은 모든 열이 1의 범위를 가져야 합리적으로 스케일링되어야 합니다.</br>\n            버전 7.3-32 이전에 method = \"cloglog\"는 혼란스럽게도 로그-로그 링크를 제공하며, 첫 번째 반응 수준이 '최고'라고 암묵적으로 가정합니다.</br>\n            <br/>\n            <b>예제</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## 약간 더 나쁜 적합도<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## 비록 적절하지는 않지만, 적합할 수 있습니다<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>패키지</b></br>\n            MASS</br>\n            <b>도움말</b></br>\n            자세한 도움말은 이 대화 상자의 오른쪽 상단에 있는 R 아이콘을 클릭하거나 R 코드 청크를 생성하여 help(polr, package =MASS) 명령을 실행하여 확인하십시오."
  }
}