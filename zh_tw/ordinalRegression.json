{
  "title": "序數回歸",
  "navigation": "序數",
  "label1": "測試方法",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "輸入模型名稱",
  "dependent": "因變量",
  "formula": "自變量",
  "generateplotchk": "繪製殘差與擬合、正態Q-Q、尺度-位置和殘差與杠杆的圖",
  "weights": "指定一個權重變量",
  "help": {
    "title": "序數",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>描述</b></br>\n            擬合一個邏輯或概率回歸模型到一個有序因子響應。默認的邏輯情況是比例賠率邏輯回歸，函數以此命名。\n            <br/>\n            <b>用法</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>參數</b><br/>\n            <ul>\n            <li>\n            formula: 一個公式表達式，形式為響應 ~ 預測變量。響應應為一個因子（最好是有序因子），將被解釋為有序響應，級別按因子的順序排列。模型必須有一個截距：嘗試去掉一個將導致警告並被忽略。可以使用偏移量。關於其他細節，請參見公式的文檔。\n            </li>\n            <li>\n            data: 一個可選的數據框，用於解釋公式中出現的變量。\n            </li>\n            <li>\n            weights: 擬合時的可選案例權重。默認為1。\n            </li>\n            <li>\n            start: 參數的初始值。格式為c(係數, zeta)：見值部分。\n            </li>\n            <li>\n            ... 傳遞給optim的附加參數，通常是控制參數。\n            </li>\n            <li>\n            subset: 表達式，說明應使用數據的哪一部分行進行擬合。默認情況下包括所有觀察。\n            </li>\n            <li>\n            na.action: 用於過濾缺失數據的函數。\n            </li>\n            <li>\n            contrasts: 用於模型公式中作為變量出現的一些或所有因子的對比列表。\n            </li>\n            <li>\n            Hess: 邏輯值，指示是否應返回Hessian（觀察信息矩陣）。如果您打算在擬合上調用summary或vcov，請使用此選項。\n            </li>\n            <li>\n            model: 邏輯值，指示是否應返回模型矩陣。\n            </li>\n            <li>\n            method: 邏輯或概率或（補充）對數-對數或cauchit（對應於Cauchy潛變量）。\n            </li>\n            </ul>\n            <b>細節</b></br>\n            該模型是Agresti（2002）所稱的累積鏈接模型。基本解釋是作為潛變量Y_i的粗化版本，具有邏輯或正態或極值或Cauchy分佈，尺度參數為1，並且均值的線性模型。觀察到的有序因子是Y_i落入的哪個區間，斷點為\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            這導致模型</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            對於正態潛變量，logit被probit替換，eta是線性預測器，是解釋變量的線性函數（沒有截距）。請注意，其他軟件通常使用eta的相反符號（因此係數beta）。</br>\n            在邏輯情況下，最後顯示的左側是類別k或更少的對數賠率，由於這些是僅因常數而異的對數賠率，因此賠率是成比例的。因此，稱為比例賠率邏輯回歸。</br>\n            對數-對數和補充對數-對數鏈接是遞增函數F^-1(p) = -log(-log(p))和F^-1(p) = log(-log(1-p)); 有人稱第一個為“負對數-對數”鏈接。這對應於具有極值分佈的潛變量，分別用於最大值和最小值。</br>\n            通過使用補充對數-對數鏈接，按增加時間分組的生存時間的比例風險模型可以獲得。</br>\n            predict, summary, vcov, anova, model.frame和用於stepAIC（和step）的extractAIC方法。還有profile和confint方法。</br>\n            <b>值</b><br/>\n            一個\"polr\"類的對象。它具有以下組件\n            <li>\n            coefficients: 線性預測器的係數，沒有截距。\n            </li>\n            <li>\n            zeta: 類邊界的截距。\n            </li>\n            <li>\n            deviance: 殘差偏差。\n            </li>\n            <li>\n            fitted.values: 一個矩陣，每個響應級別有一列。\n            </li>\n            <li>\n            lev: 響應級別的名稱。\n            </li>\n            <li>\n            terms: 描述模型的術語結構。\n            </li>\n            <li>\n            df.residual: 使用權重計算的殘差自由度數。\n            </li>\n            <li>\n            edf: 模型使用的（有效）自由度數\n            </li>\n            <li>\n            n, nobs: 使用權重計算的（有效）觀察數。（nobs用於stepAIC。\n            </li>\n            <li>\n            call: 匹配的調用。\n            </li>\n            <li>\n            method: 使用的匹配方法。\n            </li>\n            <li>\n            convergence: optim返回的收斂代碼。\n            </li>\n            <li>\n            niter: optim使用的函數和梯度評估的數量。\n            </li>\n            <li>\n            lp: 線性預測器（包括任何偏移量）。</li>\n            <li>\n            Hessian: （如果Hess為真）。請注意，這是一個從優化過程中得出的數值近似。\n            </li>\n            <li>\n            model:(如果模型為真)。\n            </li>\n            <li>\n            注意</br>\n            vcov方法使用近似Hessian：為了獲得可靠的結果，模型矩陣應合理縮放，所有列的範圍應為1的數量級。</br>\n            在版本7.3-32之前，method = \"cloglog\"令人困惑地給出了對數-對數鏈接，隱含假設第一個響應級別是“最佳”。</br>\n            <br/>\n            <b>示例</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## 稍微差一些的擬合<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## 儘管這並不真正合適，可以擬合<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>包</b></br>\n            MASS</br>\n            <b>幫助</b></br>\n            要詳細幫助，請單擊此對話框覆蓋右上角的R圖標，或通過創建R代碼塊單擊輸出窗口中的+運行以下命令help(polr, package =MASS) \t\t\t"
  }
}