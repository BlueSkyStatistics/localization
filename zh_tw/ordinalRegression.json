{
  "title": "序數回歸",
  "navigation": "序數",
  "label1": "測試方法",
  "logit": "邏輯斯回歸",
  "probit": "概率單位回歸",
  "modelname": "輸入模型名稱",
  "dependent": "因變量",
  "formula": "自變量",
  "generateplotchk": "繪製殘差與擬合值、正態Q-Q、比例位置和殘差與杠桿的圖",
  "weights": "指定一個權重變量",
  "help": {
    "title": "序數",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>描述</b></br>\n            將邏輯斯或概率單位回歸模型擬合到有序因子響應。默認的邏輯斯情況是比例賠率邏輯斯回歸，該函數以此命名。\n            <br/>\n            <b>用法</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>參數</b><br/>\n            <ul>\n            <li>\n            formula: 一個公式表達式，形式為響應 ~ 預測變量。響應應該是一個因子（最好是有序因子），將被解釋為有序響應，其級別按因子的順序排列。模型必須有一個截距：嘗試刪除一個將導致警告並被忽略。可以使用偏移量。請參見公式的文檔以獲取其他詳細信息。\n            </li>\n            <li>\n            data: 一個可選的數據框，用於解釋公式中出現的變量。\n            </li>\n            <li>\n            weights: 擬合中的可選案例權重。默認為1。\n            </li>\n            <li>\n            start: 參數的初始值。格式為c(係數, zeta)：請參見值部分。\n            </li>\n            <li>\n            ... 其他要傳遞給optim的參數，最常見的是控制參數。\n            </li>\n            <li>\n            subset: 表達式，說明應該使用數據的哪個子集進行擬合。默認情況下包括所有觀察。\n            </li>\n            <li>\n            na.action: 用於過濾缺失數據的函數。\n            </li>\n            <li>\n            contrasts: 用於模型公式中出現的某些或所有因子的對比列表。\n            </li>\n            <li>\n            Hess: 邏輯值，指是否應返回Hessian（觀察信息矩陣）。如果您打算在擬合上調用summary或vcov，請使用此選項。\n            </li>\n            <li>\n            model: 邏輯值，指是否應返回模型矩陣。\n            </li>\n            <li>\n            method: 邏輯斯或概率單位或（補充）對數-對數或cauchit（對應於Cauchy潛變量）。\n            </li>\n            </ul>\n            <b>詳細信息</b></br>\n            此模型是Agresti（2002）所稱的累積鏈接模型。基本解釋是作為潛變量Y_i的粗化版本，該變量具有邏輯斯或正態或極值或Cauchy分佈，比例參數為1，並且對均值的線性模型。觀察到的有序因子是Y_i落入的哪個區間，斷點為\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            這導致模型</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            對於正態潛變量，logit被probit替換，eta是線性預測器，是解釋變量的線性函數（沒有截距）。請注意，其他軟件通常使用相反的符號表示eta（因此係數beta）。</br>\n            在邏輯斯情況下，最後顯示的左側是k或更少類別的對數賠率，並且由於這些是僅由常數不同的對數賠率，因此賠率是成比例的。因此，稱為比例賠率邏輯斯回歸。</br>\n            對數-對數和補充對數-對數鏈接是增長函數F^-1(p) = -log(-log(p))和F^-1(p) = log(-log(1-p)); 有些人稱第一個為‘負對數-對數’鏈接。這些對應於具有極值分佈的潛變量，最大值和最小值分別。</br>\n            可以通過使用補充對數-對數鏈接，按增加的時間分組來獲得分組生存時間的比例風險模型。</br>\n            predict, summary, vcov, anova, model.frame和用於stepAIC（和step）的extractAIC方法。還有profile和confint方法。</br>\n            <b>值</b><br/>\n            一個類別為\"polr\"的對象。這具有以下組件\n            <li>\n            coefficients: 線性預測器的係數，沒有截距。\n            </li>\n            <li>\n            zeta: 類邊界的截距。\n            </li>\n            <li>\n            deviance: 殘差偏差。\n            </li>\n            <li>\n            fitted.values: 一個矩陣，每個響應級別有一列。\n            </li>\n            <li>\n            lev: 響應級別的名稱。\n            </li>\n            <li>\n            terms: 描述模型的項結構。\n            </li>\n            <li>\n            df.residual: 使用權重計算的殘差自由度數量。\n            </li>\n            <li>\n            edf: 模型使用的（有效）自由度數量\n            </li>\n            <li>\n            n, nobs: 使用權重計算的（有效）觀察數量。（nobs用於stepAIC。\n            </li>\n            <li>\n            call: 匹配的調用。\n            </li>\n            <li>\n            method: 使用的匹配方法。\n            </li>\n            <li>\n            convergence: optim返回的收斂代碼。\n            </li>\n            <li>\n            niter: optim使用的函數和梯度評估的數量。\n            </li>\n            <li>\n            lp: 線性預測器（包括任何偏移量）。</li>\n            <li>\n            Hessian: （如果Hess為真）。請注意，這是從優化過程中得出的數值近似。\n            </li>\n            <li>\n            model:(如果模型為真)。\n            </li>\n            <li>\n            注意</br>\n            vcov方法使用近似Hessian：為了獲得可靠的結果，模型矩陣應合理縮放，所有列的範圍應為1的順序。</br>\n            在版本7.3-32之前，method = \"cloglog\"令人困惑地給出了對數-對數鏈接，隱含假設第一個響應級別是‘最佳’。</br>\n            <br/>\n            <b>示例</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## 輕微較差的擬合來自<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## 雖然這並不真的合適，可以擬合<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>包</b></br>\n            MASS</br>\n            <b>幫助</b></br>\n            有關詳細幫助，請單擊此對話框右上角的R圖標，或通過創建R代碼塊，運行以下命令help(polr, package =MASS)。\t\t\t"
  }
}