{
  "title": "ANOVA 與似然比檢驗",
  "navigation": "ANOVA 與似然比",
  "label1": "ANOVA 適用於以下類別的模型（括號內為 R 類別）線性模型（lm）、廣義線性模型（glm）、負二項對數線性模型（negbin）、使用廣義最小二乘法的線性模型（gls）、生存回歸模型（survreg）、比例風險模型（coxph）、Loess 回歸（loess）",
  "label2": "**注意：對於通過模型調整（類別 train）創建的模型，不支持似然檢驗，",
  "modelselector1": "選擇模型",
  "help": {
    "title": "ANOVA 與似然比檢驗",
    "r_help": "help(anova,package='stats')",
    "body": "\n                <b>描述</b></br>\nANOVA 表：計算方差分析表並對擬合模型對象執行似然比檢驗。對於混合效應模型，隨機效應的 ANOVA 類表將被顯示。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nanova(object, ...)\n</code> <br/>\n<b>參數</b><br/>\n<ul>\n<li>\nobject: 包含模型擬合函數（例如 lm 或 glm）返回結果的對象。\n</li>\n</ul>\n<b>值</b><br/>\n此（通用）函數返回一個 anova 類的對象。這些對象表示方差分析和偏差分析表。當給定單個參數時，它生成一個表，測試模型項是否顯著。當給定一系列對象時，anova 按指定順序測試模型之間的關係。<br/>\nanova 對象的打印方法以“美觀”的形式打印表格。<br/>\n<b>警告</b><br/>\n兩個或多個模型之間的比較僅在它們擬合於相同數據集時有效。如果存在缺失值，並且使用 R 的默認 na.action = na.omit，則可能會出現問題。<br/>\n<b>包</b></br>\nstats</br>\n<b>幫助</b></br>\n有關詳細幫助，請單擊此對話框覆蓋右上角的 R 圖標，或在 R 語法編輯器中運行以下命令 help(anova,package='stats')</br></br>\n<b>描述</b></br>\n嵌套模型的似然比檢驗：lrtest 是一個通用函數，用於執行似然比檢驗。默認方法可用於比較嵌套（廣義）線性模型（見下文詳細信息）。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nlrtest(object, ...)<br/>\n## 默認 S3 方法：<br/>\nlrtest(object, ..., name = NULL) <br/>\n## S3 類 'formula' 的方法<br/>\nlrtest(object, ..., data = list())<br/>\n</code> <br/>\n<b>參數</b><br/>\n<ul>\n<li>\nobject: 一個對象。詳情見下文。\n</li>\n<li>\n...: 傳遞給方法的進一步對象規格。詳情見下文。\n</li>\n<li>\nname: 從擬合模型對象中提取合適名稱/描述的函數。默認情況下，通過調用公式查詢名稱。\n</li>\n<li>\ndata: 包含模型中變量的數據框。\n</li>\n</ul>\n<b>詳細信息</b></br>\nlrtest 旨在成為通過漸近似然比檢驗比較模型的通用函數。默認方法依次比較擬合模型對象與傳遞的模型。在 ... 中傳遞擬合模型對象時，可以使用整數、字符（兩者用於從先前模型中消除的項）、更新公式或擬合模型對象來指定。除了最後一種情況外，假定存在更新方法。詳情見 waldtest。<br/>\n隨後，對每兩個連續模型進行漸近似然比檢驗：兩倍的對數似然差（由 logLik 方法得出）與卡方分布進行比較。<br/>\n“公式”方法首先擬合 lm，然後調用默認方法。<br/>\n<b>值</b><br/>\n一個 anova 類的對象，其中包含對數似然、自由度、自由度差、似然比卡方統計量和相應的 p 值。\n<b>示例</b><br/>\n<code> \n## 使用 Greene（1993）中的數據：<br/>\n## 加載數據並計算滯後<br/>\ndata(\"USDistLag\")<br/>\nusdl <- na.contiguous(cbind(USDistLag, lag(USDistLag, k = -1)))<br/>\ncolnames(usdl) <- c(\"con\", \"gnp\", \"con1\", \"gnp1\")<br/>\nfm1 <- lm(con ~ gnp + gnp1, data = usdl)<br/>\nfm2 <- lm(con ~ gnp + con1 + gnp1, data = usdl)<br/>\n## 各種 LR 檢驗的等效規格<br/>\nlrtest(fm2, fm1)<br/>\nlrtest(fm2, 2)<br/>\nlrtest(fm2, \"con1\")<br/>\nlrtest(fm2, . ~ . - con1)<br/>\n</code> <br/>\n<b>描述</b></br>\nANOVA 類表的隨機效應：計算一個 ANOVA 類表，測試模型中的隨機效應項。每個隨機效應項被減少或移除，並以類似於 drop1 的形式呈現模型減少的似然比檢驗。\n<br/>\n<b>用法</b>\n<br/>\n<code> \nranova(model, reduce.terms = TRUE, ...)<br/>\nrand(model, reduce.terms = TRUE, ...)<br/>\n</code> <br/>\n<b>參數</b><br/>\n<ul>\n<li>\nmodel: 使用 lmer() 擬合的線性混合效應模型（繼承自類 lmerMod）。\n</li>\n<li>\nreduce.terms: 如果為 TRUE（默認），則隨機效應項被減少（如果可能）。如果為 FALSE，則隨機效應項僅被移除。\n</li>\n</ul>\n<b>詳細信息</b></br>\n如果模型使用 REML 擬合，則檢驗為 REML 似然比檢驗。<br/>\n形式為 (f1 + f2 | gr) 的隨機效應項被減少為形式為 (f2 | gr) 和 (f1 | gr) 的項，這些減少的模型與原始模型進行比較。如果 reduce.terms 為 FALSE，則 (f1 + f2 | gr) 將被移除。<br/>\n形式為 (f1 | gr) 的隨機效應項被減少為 (1 | gr)（除非 reduce.terms 為 FALSE）。<br/>\n形式為 (1 | gr) 的隨機效應項不會被減少，而是簡單地移除。<br/>\n形式為 (0 + f1 | gr) 或 (-1 + f1 | gr) 的隨機效應項被減少（如果 reduce.terms = TRUE）為 (1 | gr)。<br/>\n形式為 (1 | gr1/gr2) 的隨機效應項自動擴展為兩項：(1 | gr2:gr1) 和 (1 | gr1)，使用 findbars。<br/>\n在此說明中，無論 f1 和 f2 是因子還是連續變量，都無關緊要。<br/>\n<b>值</b><br/>\n一個 ANOVA 類表，具有隨機效應的單項刪除，繼承自 anova 類和數據框，包含以下列：</br>\nnpar: 模型參數的數量。</br>\nlogLik: 模型的對數似然。請注意，如果模型使用 REML 擬合，則這是 REML-logLik。</br>\nAIC: 模型的 AIC，評估為 -2*(logLik - npar)。越小越好。</br>\nLRT: 似然比檢驗統計量；對數似然的兩倍差異，漸近地服從卡方分布。</br>\nDf: 似然比檢驗的自由度：模型參數數量的差異。</br>\nPr(>Chisq) :p 值。</br>\n<b>警告</b></br>\n在某些情況下，可能會生成非嵌套模型的檢驗。例如，當 (0 + poly(x, 2) | gr) 被減少（默認）為 (1 | gr) 時。根據我們的最佳知識，非嵌套模型比較僅在統計上毫無意義的情況下生成（例如在此示例中，隨機截距被抑制）。</br>\n注意：anova 可用於比較兩個模型，並且通常能夠生成與 ranova 相同的檢驗。然而，這並不總是如此，如示例所示。</br>\n<b>示例</b><br/>\n<code> \n# 測試將 (Days | Subject) 減少為 (1 | Subject)：<br/>\nfm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)<br/>\nranova(fm1) # 2 df 檢驗<br/>\n# 此檢驗也可以通過 anova() 實現：<br/>\nfm2 <- lmer(Reaction ~ Days + (1|Subject), sleepstudy)<br/>\nanova(fm1, fm2, refit=FALSE)<br/>\n# 演示 reduce.test 參數：<br/>\n# 測試移除 (Days | Subject)：<br/>\nranova(fm1, reduce.terms = FALSE) # 3 df 檢驗<br/>\n# 在這種情況下，似然比檢驗統計量為：<br/>\nfm3 <- lm(Reaction ~ Days, sleepstudy)<br/>\n2*c(logLik(fm1, REML=TRUE) - logLik(fm3, REML=TRUE)) # LRT<br/>\n# anova() 並不總是能夠執行與 ranova() 相同的檢驗：<br/>\n# 例如：<br/>\nanova(fm1, fm3, refit=FALSE) # 比較 REML 與 ML，不應使用<br/>\nanova(fm1, fm3, refit=TRUE) # 是 ML 擬合的檢驗，而不是我們所尋求的<br/>\n# 還要注意，lmer 擬合需要首先進行，而不是 lm 擬合：<br/>\n# anova(fm3, fm1) # 不起作用並給出錯誤<br/>\n# ranova() 可能不會生成所有相關檢驗：<br/>\n# 對於以下模型，ranova() 指示我們不應減少<br/>\n# (TVset | Assessor)：<br/>\nfm <- lmer(Coloursaturation ~ TVset * Picture + (TVset | Assessor), data=TVbo)<br/>\nranova(fm)<br/>\n# 然而，更合適的模型是：<br/>\nfm2 <- lmer(Coloursaturation ~ TVset * Picture + (1 | TVset:Assessor), data=TVbo)<br/>\nanova(fm, fm2, refit=FALSE)<br/>\n# fm 和 fm2 對數據的擬合基本相同，但 fm 使用的參數比 fm 多 5 個。<br/>\n</code> <br/>\n<b>包</b></br>\nlmerTest</br>\n<b>幫助</b></br>\n有關詳細幫助，請單擊此對話框覆蓋右上角的 R 圖標，或在 R 語法編輯器中運行以下命令 help(ranova, package ='lmerTest')\n                "
  }
}