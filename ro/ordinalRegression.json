{
  "title": "Regresie Ordinală",
  "navigation": "Ordinal",
  "label1": "Metodă de testare",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Introduceți numele modelului",
  "dependent": "Variabilă dependentă",
  "formula": "Variabilă(e) independent(e)",
  "generateplotchk": "Plotați reziduurile vs ajustate, Q-Q normal, scală-locație și reziduuri vs leverage",
  "weights": "Specificați o variabilă cu greutăți",
  "help": {
    "title": "Ordinal",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Descriere</b></br>\n            Se potrivește un model de regresie logistică sau probit la o răspuns de factor ordonat. Cazul logistic implicit este regresia logistică a șanselor proporționale, după care este numită funcția.\n            <br/>\n            <b>Utilizare</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argumente</b><br/>\n            <ul>\n            <li>\n            formula: o expresie de formulă ca pentru modelele de regresie, de forma răspuns ~ predictori. Răspunsul ar trebui să fie un factor (preferabil un factor ordonat), care va fi interpretat ca un răspuns ordinal, cu niveluri ordonate ca în factor. Modelul trebuie să aibă o intersecție: încercările de a elimina una vor genera un avertisment și vor fi ignorate. Se poate folosi un offset. Consultați documentația formulei pentru alte detalii.\n            </li>\n            <li>\n            data: un cadru de date opțional în care să interpreteze variabilele care apar în formulă.\n            </li>\n            <li>\n            weights: greutăți opționale de caz în ajustare. Implicit la 1.\n            </li>\n            <li>\n            start: valori inițiale pentru parametrii. Acesta este în formatul c(coefficients, zeta): consultați secțiunea Valori.\n            </li>\n            <li>\n            ... argumente suplimentare care vor fi transmise la optim, cel mai adesea un argument de control.\n            </li>\n            <li>\n            subset: expresie care spune ce subset din rândurile datelor ar trebui utilizat în ajustare. Toate observațiile sunt incluse implicit.\n            </li>\n            <li>\n            na.action: o funcție pentru a filtra datele lipsă.\n            </li>\n            <li>\n            contrasts: o listă de contraste care vor fi utilizate pentru unele sau toate factorii care apar ca variabile în formula modelului.\n            </li>\n            <li>\n            Hess: logic pentru dacă Hessianul (matricea de informație observată) ar trebui să fie returnat. Folosiți acest lucru dacă intenționați să apelați rezumat sau vcov pe ajustare.\n            </li>\n            <li>\n            model: logic pentru dacă matricea modelului ar trebui să fie returnată.\n            </li>\n            <li>\n            method: logistic sau probit sau (complementar) log-log sau cauchit (corespunzător unei variabile latente Cauchy).\n            </li>\n            </ul>\n            <b>Detalii</b></br>\n            Acest model este ceea ce Agresti (2002) numește un model de legătură cumulativă. Interpretarea de bază este ca o versiune coarsened a unei variabile latente Y_i care are o distribuție logistică sau normală sau de valoare extremă sau Cauchy cu parametru de scară unu și un model liniar pentru medie. Factorul ordonat care este observat este în ce bin cade Y_i cu puncte de rupere\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Acest lucru duce la model</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            cu logit înlocuit de probit pentru o variabilă latentă normală, și eta fiind predictorul liniar, o funcție liniară a variabilelor explicative (fără intersecție). Rețineți că este destul de comun ca alte software-uri să folosească semnul opus pentru eta (și prin urmare coeficientele beta).</br>\n            În cazul logistic, partea stângă a ultimei afișări este log-șansele categoriei k sau mai puțin, și deoarece acestea sunt log-șanse care diferă doar printr-o constantă pentru diferite k, șansele sunt proporționale. De aici termenul regresie logistică a șanselor proporționale.</br>\n            Legăturile log-log și log-log complementare sunt funcțiile crescătoare F^-1(p) = -log(-log(p)) și F^-1(p) = log(-log(1-p)); unii numesc prima legătura de 'log-log negativ'. Acestea corespund unei variabile latente cu distribuția de valoare extremă pentru maxim și minim respectiv.</br>\n            Un model de riscuri proporționale pentru timpi de supraviețuire grupate poate fi obținut folosind legătura log-log complementară cu grupare ordonată după timpi în creștere.</br>\n            predict, summary, vcov, anova, model.frame și o metodă extractAIC pentru utilizare cu stepAIC (și step). Există, de asemenea, metode de profil și confint.</br>\n            <b>Valoare</b><br/>\n            Un obiect de clasă \"polr\". Acesta are componente\n            <li>\n            coefficients: coeficientii predictorului liniar, care nu are intersecție.\n            </li>\n            <li>\n            zeta: intersecțiile pentru limitele de clasă.\n            </li>\n            <li>\n            deviance: devianța reziduală.\n            </li>\n            <li>\n            fitted.values: o matrice, cu o coloană pentru fiecare nivel al răspunsului.\n            </li>\n            <li>\n            lev: numele nivelurilor de răspuns.\n            </li>\n            <li>\n            terms: structura termenilor care descrie modelul.\n            </li>\n            <li>\n            df.residual: numărul de grade de libertate reziduale, calculat folosind greutățile.\n            </li>\n            <li>\n            edf: numărul (efectiv) de grade de libertate utilizate de model\n            </li>\n            <li>\n            n, nobs: numărul (efectiv) de observații, calculat folosind greutățile. (nobs este pentru utilizare de către stepAIC.\n            </li>\n            <li>\n            call: apelul corespunzător.\n            </li>\n            <li>\n            method: metoda corespunzătoare utilizată.\n            </li>\n            <li>\n            convergence: codul de convergență returnat de optim.\n            </li>\n            <li>\n            niter: numărul de evaluări de funcție și gradient utilizate de optim.\n            </li>\n            <li>\n            lp: predictorul liniar (inclusiv orice offset).</li>\n            <li>\n            Hessian: (dacă Hess este adevărat). Rețineți că aceasta este o aproximare numerică derivată din procesul de optimizare.\n            </li>\n            <li>\n            model:(dacă modelul este adevărat).\n            </li>\n            <li>\n            Notă</br>\n            Metoda vcov utilizează Hessianul aproximativ: pentru rezultate fiabile, matricea modelului ar trebui să fie scalată în mod rezonabil cu toate coloanele având un interval de ordinul unu.</br>\n            Înainte de versiunea 7.3-32, metoda = \"cloglog\" confuz a dat legătura log-log, presupunând implicit că primul nivel de răspuns era 'cel mai bun'.</br>\n            <br/>\n            <b>Exemple</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## ajustare ușor mai proastă de<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## deși nu este cu adevărat adecvat, se poate ajusta<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Pachet</b></br>\n            MASS</br>\n            <b>Ajutor</b></br>\n            Pentru ajutor detaliat, faceți clic pe pictograma R din colțul din dreapta sus al acestui dialog sau rulați următoarea comandă help(polr, package =MASS) creând un bloc de cod R făcând clic pe + în fereastra de ieșire\t\t\t"
  }
}