{
  "title": "Regressione Ordinale",
  "navigation": "Ordinale",
  "label1": "Metodo di test",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Inserisci il nome del modello",
  "dependent": "Variabile dipendente",
  "formula": "Variabile(i) indipendente(i)",
  "generateplotchk": "Traccia i residui vs adattati, Q-Q normale, scala-locazione e residui vs leva",
  "weights": "Specifica una variabile con pesi",
  "help": {
    "title": "Ordinale",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Descrizione</b></br>\n            Adatta un modello di regressione logistica o probit a una risposta di fattore ordinato. Il caso logico predefinito è la regressione logistica a odds proporzionali, dopo la quale la funzione è nominata.\n            <br/>\n            <b>Utilizzo</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argomenti</b><br/>\n            <ul>\n            <li>\n            formula: un'espressione di formula come per i modelli di regressione, della forma risposta ~ predittori. La risposta dovrebbe essere un fattore (preferibilmente un fattore ordinato), che sarà interpretato come una risposta ordinata, con livelli ordinati come nel fattore. Il modello deve avere un'intercetta: tentativi di rimuoverne una porteranno a un avviso e saranno ignorati. Può essere utilizzato un offset. Vedi la documentazione della formula per ulteriori dettagli.\n            </li>\n            <li>\n            data: un data frame opzionale in cui interpretare le variabili che compaiono nella formula.\n            </li>\n            <li>\n            weights: pesi opzionali per i casi nell'adattamento. Predefinito a 1.\n            </li>\n            <li>\n            start: valori iniziali per i parametri. Questo è nel formato c(coefficienti, zeta): vedi la sezione Valori.\n            </li>\n            <li>\n            ... argomenti aggiuntivi da passare a ottim, più spesso un argomento di controllo.\n            </li>\n            <li>\n            subset: espressione che indica quale sottoinsieme delle righe dei dati dovrebbe essere utilizzato nell'adattamento. Tutte le osservazioni sono incluse per impostazione predefinita.\n            </li>\n            <li>\n            na.action: una funzione per filtrare i dati mancanti.\n            </li>\n            <li>\n            contrasts: un elenco di contrasti da utilizzare per alcuni o tutti i fattori che compaiono come variabili nella formula del modello.\n            </li>\n            <li>\n            Hess: logico per indicare se la Hessiana (la matrice delle informazioni osservate) dovrebbe essere restituita. Usa questo se intendi chiamare il sommario o vcov sull'adattamento.\n            </li>\n            <li>\n            model: logico per indicare se la matrice del modello dovrebbe essere restituita.\n            </li>\n            <li>\n            method: logistica o probit o (complementare) log-log o cauchit (corrispondente a una variabile latente di Cauchy).\n            </li>\n            </ul>\n            <b>Dettagli</b></br>\n            Questo modello è ciò che Agresti (2002) chiama un modello di collegamento cumulativo. L'interpretazione di base è come una versione coarsened di una variabile latente Y_i che ha una distribuzione logistica o normale o di valore estremo o di Cauchy con parametro di scala uno e un modello lineare per la media. Il fattore ordinato che viene osservato è quale bin Y_i cade con punti di rottura\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Questo porta al modello</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            con logit sostituito da probit per una variabile latente normale, e eta che è il predittore lineare, una funzione lineare delle variabili esplicative (senza intercetta). Nota che è abbastanza comune per altri software utilizzare il segno opposto per eta (e quindi i coefficienti beta).</br>\n            Nel caso logistico, il lato sinistro dell'ultima visualizzazione è il log odds di categoria k o meno, e poiché questi sono log odds che differiscono solo per una costante per diversi k, le odds sono proporzionali. Ecco perché si parla di regressione logistica a odds proporzionali.</br>\n            I collegamenti log-log e log-log complementari sono le funzioni crescenti F^-1(p) = -log(-log(p)) e F^-1(p) = log(-log(1-p)); alcuni chiamano il primo il collegamento 'log-log negativo'. Questi corrispondono a una variabile latente con la distribuzione di valore estremo per il massimo e il minimo rispettivamente.</br>\n            Un modello di rischi proporzionali per i tempi di sopravvivenza raggruppati può essere ottenuto utilizzando il collegamento log-log complementare con raggruppamento ordinato per tempi crescenti.</br>\n            predict, summary, vcov, anova, model.frame e un metodo extractAIC per l'uso con stepAIC (e step). Ci sono anche metodi di profilo e confint.</br>\n            <b>Valore</b><br/>\n            Un oggetto di classe \"polr\". Questo ha componenti\n            <li>\n            coefficients: i coefficienti del predittore lineare, che non ha intercetta.\n            </li>\n            <li>\n            zeta: le intercette per i confini di classe.\n            </li>\n            <li>\n            deviance: la devianza residua.\n            </li>\n            <li>\n            fitted.values: una matrice, con una colonna per ciascun livello della risposta.\n            </li>\n            <li>\n            lev: i nomi dei livelli di risposta.\n            </li>\n            <li>\n            terms: la struttura dei termini che descrive il modello.\n            </li>\n            <li>\n            df.residual: il numero di gradi di libertà residui, calcolato utilizzando i pesi.\n            </li>\n            <li>\n            edf: il numero (effettivo) di gradi di libertà utilizzati dal modello\n            </li>\n            <li>\n            n, nobs: il numero (effettivo) di osservazioni, calcolato utilizzando i pesi. (nobs è per l'uso da parte di stepAIC.\n            </li>\n            <li>\n            call: la chiamata corrispondente.\n            </li>\n            <li>\n            method: il metodo corrispondente utilizzato.\n            </li>\n            <li>\n            convergence: il codice di convergenza restituito da ottim.\n            </li>\n            <li>\n            niter: il numero di valutazioni della funzione e del gradiente utilizzate da ottim.\n            </li>\n            <li>\n            lp: il predittore lineare (incluso qualsiasi offset).</li>\n            <li>\n            Hessian: (se Hess è vero). Nota che questa è un'approssimazione numerica derivata dal processo di ottimizzazione.\n            </li>\n            <li>\n            model:(se il modello è vero).\n            </li>\n            <li>\n            Nota</br>\n            Il metodo vcov utilizza la Hessiana approssimativa: per risultati affidabili la matrice del modello dovrebbe essere scalata in modo sensato con tutte le colonne che hanno un intervallo dell'ordine di uno.</br>\n            Prima della versione 7.3-32, il metodo = \"cloglog\" dava confusamente il collegamento log-log, assumendo implicitamente che il primo livello di risposta fosse il 'migliore'.</br>\n            <br/>\n            <b>Esempi</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## adattamento leggermente peggiore da<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## anche se non è davvero appropriato, può adattarsi<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Pacchetto</b></br>\n            MASS</br>\n            <b>Aiuto</b></br>\n            Per aiuto dettagliato clicca sull'icona R in alto a destra di questo overlay di dialogo o esegui il seguente comando help(polr, package =MASS) creando un blocco di codice R cliccando + nella finestra di output\t\t\t"
  }
}