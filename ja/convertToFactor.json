{
  "title": "因子に変換",
  "navigation": "因子へ",
  "trg": "因子に変換される変数",
  "help": {
    "title": "因子に変換",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>説明</b></br>\nfactor関数は、ベクトルを因子としてエンコードするために使用されます（因子には「カテゴリ」や「列挙型」という用語も使用されます）。引数orderedがTRUEの場合、因子レベルは順序があると見なされます。Sとの互換性のために、orderedという関数もあります。\nis.factor、is.ordered、as.factor、as.orderedは、これらのクラスのメンバーシップおよび強制変換関数です。\n<br/>\n<b>使用法</b>\n<br/>\n<code>\nfactor(x = character(), levels, labels = levels,\n        exclude = NA, ordered = is.ordered(x), nmax = NA)\nordered(x, ...)\nis.factor(x)\nis.ordered(x)\nas.factor(x)\nas.ordered(x)\naddNA(x, ifany = FALSE)\n</code> <br/>\n<b>引数</b><br/>\n<ul>\n<li>\nx: データのベクトルで、通常は少数の異なる値を取ります。\n</li>\n<li>\nlevels: xが取る可能性のある値のオプションのベクトル（文字列として）。デフォルトは、as.character(x)によって取られたユニークな値のセットで、xの増加順にソートされます。このセットは、sort(unique(x))よりも小さく指定できます。\n</li>\n<li>\nlabels: レベルのラベルのオプションの文字ベクトル（excludeで削除された後のlevelsと同じ順序）または長さ1の文字列。\n</li>\n<li>\nexclude: レベルのセットを形成する際に除外される値のベクトル。これはxと同じ型である必要があり、必要に応じて強制変換されます。\n</li>\n<li>\nordered: レベルが順序付きと見なされるかどうかを決定する論理フラグ。\n</li>\n<li>\nnmax: レベルの数の上限; 「詳細」を参照。\n</li>\n<li>\n...(ordered(.)): 上記のいずれか、ordered自体を除く。\n</li>\n<li>\nifany: NAレベルを使用されている場合のみ追加（すなわち、any(is.na(x))が真の場合）。\n</li>\n</ul>\n<b>詳細</b></br>\nベクトルxの型は制限されていません; それはas.characterメソッドを持ち、ソート可能である必要があります（sort.listによって）。<br/>\n順序付き因子は、クラスが異なるだけで、メソッドやモデルフィッティング関数は2つのクラスをかなり異なって扱います。<br/>\nベクトルのエンコーディングは次のように行われます。まず、excludeのすべての値がlevelsから削除されます。もしx[i]がlevels[j]に等しい場合、結果のi番目の要素はjになります。もしx[i]がlevelsで一致しない場合（除外された値に対して発生します）、結果のi番目の要素はNAに設定されます。<br/>\n通常、結果の属性として使用される「levels」は、excludeで削除された後のレベルの削減されたセットですが、labelsを供給することで変更できます。これは、レベルの新しいラベルのセットであるか、文字列である必要があります。この場合、レベルはその文字列にシーケンス番号が付加されたものになります。<br/>\nfactor(x, exclude = NULL)が因子に適用されると、未使用のレベルがある場合を除いて、操作は行われません。その場合、削減されたレベルセットを持つ因子が返されます。excludeが使用される場合、それはxと同じレベルセットを持つ因子であるか、除外されるレベルのコードのセットである必要があります。<br/>\n因子のコードにはNAが含まれる場合があります。数値xの場合、exclude = NULLを設定してNAを追加のレベルにします（<NA>として印刷されます）。デフォルトでは、これは最後のレベルです。<br/>\nNAがレベルである場合、コードを欠損として設定する方法（欠損レベルのコードとは対照的に）は、代入の左側でis.naを使用することです（is.na(f)[i] <- TRUEのように; is.naの内部でのインデクシングは機能しません）。そのような状況下では、欠損値は現在<NA>として印刷されます。すなわち、NAレベルのエントリと同一です。<br/>\nis.factorは一般的です: 特定のオブジェクトのクラスを処理するためのメソッドを書くことができます。InternalMethodsを参照してください。<br/>\nlevelsが供給されない場合、uniqueが呼び出されます。因子は通常、非常に少数のレベルを持つため、大きなベクトルxの場合、nmaxをユニークな値の上限として供給することが役立ちます。<br/>\n<b>値</b><br/>\nfactorは、xの長さの整数コードのセットを持つ\"factor\"クラスのオブジェクトを返します。\"levels\"属性はモード文字列であり、ユニークな(!anyDuplicated(.))エントリを持ちます。引数orderedがtrueの場合（またはordered()が使用される場合）、結果はc(\"ordered\", \"factor\")のクラスを持ちます。<br/>\nfactorを順序付きまたは順序なしの因子に適用すると、発生するレベルのみを持つ因子（同じ型）を返します。これを達成するためのより透明な方法については、[.factorを参照してください。\nis.factorは、引数が因子型かどうかに応じてTRUEまたはFALSEを返します。対応して、is.orderedは引数が順序付き因子である場合はTRUEを返し、そうでない場合はFALSEを返します。<br/>\nas.factorはその引数を因子に強制変換します。これはfactorの省略形です。<br/>\nas.ordered(x)は、これが順序付きである場合はxを返し、そうでない場合はordered(x)を返します。<br/>\naddNAは、NAを追加のレベルにすることによって因子を修正します（たとえば、NA値がテーブルでカウントされるように）。<br/>\n<b>パッケージ</b></br>\nbase</br>\n<b>ヘルプ</b></br>\nhelp(factor, package=fastDummies)\n"
  }
}