{
  "title": "Entscheidungsbäume",
  "navigation": "Entscheidungsbäume",
  "TxtTreeName": "Modellnamen eingeben",
  "TreeGenChkbox": "Nicht neu generieren, wenn Baum bereits existiert",
  "dependent": "Abhängige Variable",
  "independent": "Unabhängige Variable(n)",
  "weights": "Umfragegewichte",
  "TxtMinSplit": "Minimale Teilung",
  "minBucket": "Minimales Bucket",
  "TxtCP": "Komplexitätsparameter",
  "maxDepth": "Maximale Tiefe",
  "PruneTreeChkbox": "Baum beschneiden",
  "rd0": "Nicht beschneiden",
  "rd1": "Optimalen Komplexitätsparameter verwenden",
  "rd2": "Komplexitätsparameter angeben",
  "TxtCPPrune": "Komplexitätsparameter eingeben",
  "PlotCVChkbox": "Kreuzvalidierung plotten",
  "PlotRSQRChkbox": "R-Quadrat plotten",
  "OptvarPlots": "Diagramme",
  "OptvarPreprune": "Vorverzweigung",
  "OptvarPrune": "Baum beschneiden",  
  "help": {
    "title": "Entscheidungsbäume",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>Hinweis</b></br>\n                Abhängige Variablen können Faktor, ordinal, String, logisch und numerisch sein</br>\n                Unabhängige Variablen können Faktor, ordinal, String, logisch und numerisch sein</br></br>\n                <b>Beschreibung</b></br>\n                Fit eines Modells für rekursive Partitionierung und Regressionsbaum\n                <br/>\n                <b>Verwendung</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                formula: eine Formel mit einer Antwort, aber ohne Interaktionstermine. Wenn dies ein Datenrahmen ist, wird dieser als Modellrahmen verwendet (siehe model.frame).\n                </li>\n                <li>\n                data: ein optionaler Datenrahmen, in dem die in der Formel genannten Variablen interpretiert werden.\n                </li>\n                <li>\n                weights: optionale Fallgewichte.\n                </li>\n                <li>\n                subset: optionale Ausdruck, der besagt, dass nur ein Teil der Zeilen der Daten im Fit verwendet werden soll.\n                </li>\n                <li>\n                na.action: Die Standardaktion löscht alle Beobachtungen, für die y fehlt, behält jedoch diejenigen, bei denen eine oder mehrere Prädiktoren fehlen.\n                </li>\n                <li>\n                method: eine der Optionen \"anova\", \"poisson\", \"class\" oder \"exp\". Wenn die Methode fehlt, versucht die Routine, eine intelligente Vermutung anzustellen. Wenn y ein Überlebensobjekt ist, wird angenommen, dass method = \"exp\" ist, wenn y 2 Spalten hat, wird angenommen, dass method = \"poisson\" ist, wenn y ein Faktor ist, wird angenommen, dass method = \"class\" ist, andernfalls wird angenommen, dass method = \"anova\" ist. Es ist am besten, die Methode direkt anzugeben, insbesondere da in Zukunft möglicherweise weitere Kriterien zur Funktion hinzugefügt werden.\n                Alternativ kann die Methode eine Liste von Funktionen mit den Namen init, split und eval sein. Beispiele sind in der Datei 'tests/usersplits.R' in den Quellen und in den Vignetten 'Benutzerdefinierte Split-Funktionen' gegeben.\n                </li>\n                <li>\n                model: wenn logisch: eine Kopie des Modellrahmens im Ergebnis behalten? Wenn der Eingabewert für das Modell ein Modellrahmen ist (wahrscheinlich von einem früheren Aufruf der rpart-Funktion), wird dieser Rahmen anstelle der Konstruktion neuer Daten verwendet.\n                </li>\n                <li>\n                x: eine Kopie der x-Matrix im Ergebnis behalten.\n                </li>\n                <li>\n                y: eine Kopie der abhängigen Variablen im Ergebnis behalten. Wenn fehlt und das Modell bereitgestellt wird, ist dies standardmäßig FALSE.\n                </li>\n                <li>\n                parms: optionale Parameter für die Split-Funktion.<br/>\n                Anova-Splitting hat keine Parameter.<br/>\n                Poisson-Splitting hat einen einzigen Parameter, den Variationskoeffizienten der vorherigen Verteilung auf den Raten. Der Standardwert ist 1.<br/>\n                Exponential-Splitting hat denselben Parameter wie Poisson.<br/>\n                Für Klassifikationssplitting kann die Liste enthalten: den Vektor der vorherigen Wahrscheinlichkeiten (Komponente prior), die Verlustmatrix (Komponente loss) oder den Splitting-Index (Komponente split). Die Priors müssen positiv sein und sich auf 1 summieren. Die Verlustmatrix muss Nullen auf der Diagonalen und positive Elemente außerhalb der Diagonalen haben. Der Splitting-Index kann gini oder information sein. Die Standardpriors sind proportional zu den Datenanzahlen, die Verluste standardmäßig 1 und der Split standardmäßig gini.<br/>\n                </li>\n                <li>\n                control: eine Liste von Optionen, die Details des rpart-Algorithmus steuern. Siehe rpart.control.\n                </li>\n                <li>\n                cost: ein Vektor von nicht-negativen Kosten, einer für jede Variable im Modell. Standardmäßig eins für alle Variablen. Dies sind Skalierungen, die bei der Betrachtung von Splits angewendet werden, sodass die Verbesserung beim Splitten einer Variablen durch ihre Kosten geteilt wird, um zu entscheiden, welchen Split zu wählen.\n                </li>\n                <li>\n                ...: Argumente zu rpart.control können auch im Aufruf zu rpart angegeben werden. Sie werden mit der Liste der gültigen Argumente überprüft.\n                </li>\n                </ul>\n                <b>Details</b></br>\n                Dies unterscheidet sich hauptsächlich in der Handhabung von Surrogatvariablen von der tree-Funktion in S. In den meisten Details folgt es Breiman et. al (1984) ziemlich genau. Das R-Paket tree bietet eine Neuimplementierung von tree.\n                <b>Wert</b></br>\n                Ein Objekt der Klasse rpart. Siehe rpart.object.</br>\n                <b>Referenzen</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., und Stone, C. J. (1984) Klassifikation und Regressionsbäume. Wadsworth.</br>\n                <b>Siehe Auch</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Beispiele</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # sonst wird der Text auf einigen Geräten abgeschnitten</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Paket</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Hilfe</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>Beschreibung</b></br>\n                Steuerung für Rpart Fits. Verschiedene Parameter, die Aspekte des rpart-Fits steuern.\n                <br/>\n                <b>Verwendung</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argumente</b><br/>\n                <ul>\n                <li>\n                minsplit: die minimale Anzahl von Beobachtungen, die in einem Knoten vorhanden sein müssen, damit ein Split versucht wird.\n                </li>\n                <li>\n                minbucket: die minimale Anzahl von Beobachtungen in einem terminalen <leaf> Knoten. Wenn nur eines von minbucket oder minsplit angegeben ist, setzt der Code entweder minsplit auf minbucket*3 oder minbucket auf minsplit/3, je nach Bedarf.\n                </li>\n                <li>\n                cp: Komplexitätsparameter. Jeder Split, der die Gesamtanpassung nicht um einen Faktor von cp verringert, wird nicht versucht. Zum Beispiel bedeutet dies bei Anova-Splitting, dass das gesamte R-Quadrat bei jedem Schritt um cp steigen muss. Die Hauptfunktion dieses Parameters besteht darin, Rechenzeit zu sparen, indem Splits, die offensichtlich nicht lohnenswert sind, abgeschnitten werden. Im Wesentlichen informiert der Benutzer das Programm, dass jeder Split, der die Anpassung nicht um cp verbessert, wahrscheinlich durch Kreuzvalidierung abgeschnitten wird, und dass das Programm daher nicht weiterverfolgt werden muss.\n                </li>\n                <li>\n                maxcompete: die Anzahl der konkurrierenden Splits, die im Ergebnis beibehalten werden. Es ist nützlich zu wissen, welcher Split gewählt wurde, aber auch, welche Variable an zweiter, dritter Stelle usw. kam.\n                </li>\n                <li>\n                maxsurrogate: die Anzahl der Surrogat-Splits, die im Ergebnis beibehalten werden. Wenn dies auf null gesetzt ist, wird die Rechenzeit reduziert, da ungefähr die Hälfte der Rechenzeit (außer der Einrichtung) für die Suche nach Surrogat-Splits verwendet wird.\n                </li>\n                <li>\n                usesurrogate: wie Surrogates im Splitting-Prozess verwendet werden. 0 bedeutet nur anzeigen; eine Beobachtung mit einem fehlenden Wert für die primäre Split-Regel wird nicht weiter unten im Baum gesendet. 1 bedeutet, Surrogates in der Reihenfolge zu verwenden, um Subjekte zu splitten, die die primäre Variable vermissen; wenn alle Surrogates fehlen, wird die Beobachtung nicht gesplittet. Für den Wert 2, wenn alle Surrogates fehlen, wird die Beobachtung in die Mehrheit Richtung gesendet. Ein Wert von 0 entspricht der Aktion von tree, und 2 den Empfehlungen von Breiman et.al (1984).\n                </li>\n                <li>\n                xval: Anzahl der Kreuzvalidierungen.\n                </li>\n                <li>\n                surrogatestyle: steuert die Auswahl eines besten Surrogats. Wenn auf 0 (Standard) gesetzt, verwendet das Programm die Gesamtzahl der korrekten Klassifikationen für eine potenzielle Surrogatvariable, wenn auf 1 gesetzt, verwendet es den Prozentsatz der korrekten, berechnet über die nicht fehlenden Werte des Surrogats. Die erste Option bestraft Kovariaten mit einer großen Anzahl fehlender Werte strenger.\n                </li>\n                <li>\n                maxdepth: Setzt die maximale Tiefe eines Knotens des endgültigen Baums, wobei der Wurzelknoten als Tiefe 0 gezählt wird. Werte über 30 gibt rpart unsinnige Ergebnisse auf 32-Bit-Maschinen.\n                </li>\n                <li>\n                ...: andere Argumente aufräumen.\n                </li>\n                </ul>\n                <b>Wert</b></br>\n                Eine Liste, die die Optionen enthält. \n                      "
  }
}