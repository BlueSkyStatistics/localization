{
  "title": "In Faktoren umwandeln",
  "navigation": "Zu Faktor",
  "trg": "Variablen, die in Faktoren umgewandelt werden sollen",
  "help": {
    "title": "In Faktoren umwandeln",
    "r_help": "help(factor, package=base)",
    "body": "\n<b>Beschreibung</b></br>\nDie Funktion factor wird verwendet, um einen Vektor als Faktor zu kodieren (die Begriffe ‚Kategorie‘ und ‚enumerierter Typ‘ werden ebenfalls für Faktoren verwendet). Wenn das Argument ordered TRUE ist, werden die Faktorstufen als geordnet angesehen. Zur Kompatibilität mit S gibt es auch eine Funktion ordered.\nis.factor, is.ordered, as.factor und as.ordered sind die Mitgliedschafts- und Zwangsfunktionen für diese Klassen.\n<br/>\n<b>Verwendung</b>\n<br/>\n<code>\nfactor(x = character(), levels, labels = levels,\n        exclude = NA, ordered = is.ordered(x), nmax = NA)\nordered(x, ...)\nis.factor(x)\nis.ordered(x)\nas.factor(x)\nas.ordered(x)\naddNA(x, ifany = FALSE)\n</code> <br/>\n<b>Argumente</b><br/>\n<ul>\n<li>\nx: ein Vektor von Daten, der normalerweise eine kleine Anzahl von unterschiedlichen Werten annimmt.\n</li>\n<li>\nlevels:\tEin optionaler Vektor der Werte (als Zeichenfolgen), die x angenommen haben könnte. Der Standardwert ist die einzigartige Menge von Werten, die von as.character(x) angenommen werden, sortiert in aufsteigender Reihenfolge von x. Beachten Sie, dass diese Menge kleiner als sort(unique(x)) angegeben werden kann.\n</li>\n<li>\nlabels:\tEntweder ein optionaler Zeichenvektor von Bezeichnungen für die Stufen (in derselben Reihenfolge wie levels, nachdem die in exclude entfernt wurden), oder eine Zeichenfolge der Länge 1.\n</li>\n<li>\nexclude: Ein Vektor von Werten, die beim Bilden der Menge von Stufen ausgeschlossen werden sollen. Dies sollte vom gleichen Typ wie x sein und wird bei Bedarf gezwungen.\n</li>\n<li>\nordered: logische Flagge, um zu bestimmen, ob die Stufen als geordnet angesehen werden sollen (in der angegebenen Reihenfolge).\n</li>\n<li>\nnmax: eine obere Grenze für die Anzahl der Stufen; siehe ‚Details‘.\n</li>\n<li>\n...(in ordered(.)): alle oben genannten, außer ordered selbst.\n</li>\n<li>\nifany: (nur ein NA-Level hinzufügen, wenn es verwendet wird, d.h. wenn any(is.na(x)).\n</li>\n</ul>\n<b>Details</b></br>\nDer Typ des Vektors x ist nicht eingeschränkt; er muss nur eine as.character-Methode haben und sortierbar sein (durch sort.list).<br/>\nGeordnete Faktoren unterscheiden sich von Faktoren nur in ihrer Klasse, aber Methoden und die Modellanpassungsfunktionen behandeln die beiden Klassen ganz unterschiedlich.<br/>\nDie Kodierung des Vektors erfolgt wie folgt. Zuerst werden alle Werte in exclude von levels entfernt. Wenn x[i] gleich levels[j] ist, dann ist das i-te Element des Ergebnisses j. Wenn für x[i] kein Übereinstimmung in levels gefunden wird (was für ausgeschlossene Werte der Fall sein wird), wird das i-te Element des Ergebnisses auf NA gesetzt.<br/>\nNormalerweise sind die ‚levels‘, die als Attribut des Ergebnisses verwendet werden, die reduzierte Menge von levels, nachdem die in exclude entfernt wurden, aber dies kann durch die Bereitstellung von labels geändert werden. Dies sollte entweder eine Menge neuer Bezeichnungen für die Stufen sein oder eine Zeichenfolge, in diesem Fall sind die Stufen diese Zeichenfolge mit einer angehängten Sequenznummer.<br/>\nfactor(x, exclude = NULL), das auf einen Faktor angewendet wird, ist eine No-Operation, es sei denn, es gibt ungenutzte Stufen: in diesem Fall wird ein Faktor mit der reduzierten Stufenmenge zurückgegeben. Wenn exclude verwendet wird, sollte es auch ein Faktor mit dem gleichen Stufen-Set wie x oder eine Menge von Codes für die auszuschließenden Stufen sein.<br/>\nDie Codes eines Faktors können NA enthalten. Für ein numerisches x setzen Sie exclude = NULL, um NA zu einer zusätzlichen Stufe zu machen (wird als <NA> gedruckt); standardmäßig ist dies die letzte Stufe.<br/>\nWenn NA eine Stufe ist, besteht der Weg, um einen Code als fehlend festzulegen (im Gegensatz zu dem Code der fehlenden Stufe), darin, is.na auf der linken Seite einer Zuweisung zu verwenden (wie in is.na(f)[i] <- TRUE; Indizierung innerhalb von is.na funktioniert nicht). Unter diesen Umständen werden fehlende Werte derzeit als <NA> gedruckt, d.h. identisch zu den Einträgen der Stufe NA.<br/>\nis.factor ist generisch: Sie können Methoden schreiben, um spezifische Klassen von Objekten zu behandeln, siehe InternalMethods.<br/>\nWenn levels nicht angegeben ist, wird unique aufgerufen. Da Faktoren typischerweise eine recht kleine Anzahl von Stufen haben, ist es hilfreich, nmax als obere Grenze für die Anzahl der einzigartigen Werte anzugeben.<br/>\n<b>Wert</b><br/>\nfactor gibt ein Objekt der Klasse \"factor\" zurück, das eine Menge von Ganzzahl-Codes der Länge x mit einem \"levels\"-Attribut vom Modus Zeichenfolge und einzigartigen (!anyDuplicated(.)) Einträgen hat. Wenn das Argument ordered true ist (oder ordered() verwendet wird), hat das Ergebnis die Klasse c(\"ordered\", \"factor\").<br/>\nDie Anwendung von factor auf einen geordneten oder ungeordneten Faktor gibt einen Faktor (des gleichen Typs) mit nur den Stufen zurück, die auftreten: siehe auch [.factor für eine transparentere Möglichkeit, dies zu erreichen.\nis.factor gibt TRUE oder FALSE zurück, je nachdem, ob sein Argument vom Typ Faktor ist oder nicht. Entsprechend gibt is.ordered TRUE zurück, wenn sein Argument ein geordneter Faktor ist und FALSE andernfalls.<br/>\nas.factor zwingt sein Argument zu einem Faktor. Es ist eine abgekürzte Form von factor.<br/>\nas.ordered(x) gibt x zurück, wenn dies geordnet ist, und ordered(x) andernfalls.<br/>\naddNA modifiziert einen Faktor, indem NA in eine zusätzliche Stufe umgewandelt wird (so dass NA-Werte in Tabellen gezählt werden, zum Beispiel).<br/>\n<b>Paket</b></br>\nbase</br>\n<b>Hilfe</b></br>\nhelp(factor, package =fastDummies)\n"
  }
}