{
  "title": "Teste Qui-quadrado",
  "navigation": "Teste Qui-quadrado",
  "target": "Variáveis selecionadas",
  "proportions": "Teste contra proporções iguais ou insira proporções para testar. Se sua variável for gênero, deixe este controle em branco para testar proporções iguais. Para testar 20% de mulheres e 80% de homens, insira 0.2,0.8. Insira uma proporção para cada nível. As proporções devem totalizar 1.",
  "help": {
    "title": "Teste Qui-quadrado",
    "r_help": "help(chisq.test, package=stats)",
    "body": "\n<b>Descrição</b></br>\nchisq.test realiza testes de tabela de contingência qui-quadrado e testes de aderência.\n<br/>\n<b>Uso</b>\n<br/>\n<code>\nchisq.test(x, y = NULL, correct = TRUE,\n            p = rep(1/length(x), length(x)), rescale.p = FALSE,\n            simulate.p.value = FALSE, B = 2000)\n</code> <br/>\n<b>Argumentos</b><br/>\n<ul>\n<li>\nx: um vetor ou matriz numérica. x e y também podem ser fatores.\n</li>\n<li>\ny: um vetor numérico; ignorado se x for uma matriz. Se x for um fator, y deve ser um fator do mesmo comprimento.\n</li>\n<li>\ncorrect: um lógico indicando se deve aplicar correção de continuidade ao calcular a estatística do teste para tabelas 2 por 2: metade é subtraída de todas as diferenças |O - E|; no entanto, a correção não será maior do que as próprias diferenças. Nenhuma correção é feita se simulate.p.value = TRUE.\n</li>\n<li>\np: um vetor de probabilidades do mesmo comprimento que x. Um erro é gerado se qualquer entrada de p for negativa.\n</li>\n<li>\nrescale.p: um escalar lógico; se TRUE, então p é reescalado (se necessário) para somar 1. Se rescale.p for FALSE, e p não somar 1, um erro é gerado.\n</li>\n<li>\nsimulate.p.value: um lógico indicando se deve calcular valores p por simulação de Monte Carlo.\n</li>\n<li>\nB: um inteiro especificando o número de replicados usados no teste de Monte Carlo.\n</li>\n</ul>\n<b>Descrição</b><br/>\nSe x for uma matriz com uma linha ou coluna, ou se x for um vetor e y não for fornecido, então um teste de aderência é realizado (x é tratado como uma tabela de contingência unidimensional). As entradas de x devem ser inteiros não negativos. Nesse caso, a hipótese testada é se as probabilidades populacionais são iguais às de p, ou são todas iguais se p não for fornecido.\nSe x for uma matriz com pelo menos duas linhas e colunas, é considerada uma tabela de contingência bidimensional: as entradas de x devem ser inteiros não negativos. Caso contrário, x e y devem ser vetores ou fatores do mesmo comprimento; casos com valores ausentes são removidos, os objetos são convertidos em fatores, e a tabela de contingência é computada a partir destes. Então, o teste qui-quadrado de Pearson é realizado da hipótese nula de que a distribuição conjunta das contagens de células em uma tabela de contingência 2-dimensional é o produto das marginais de linha e coluna.<br/>\nSe simulate.p.value for FALSE, o valor p é computado a partir da distribuição qui-quadrado assintótica da estatística do teste; a correção de continuidade é usada apenas no caso 2 por 2 (se correct for TRUE, o padrão). Caso contrário, o valor p é computado para um teste de Monte Carlo (Hope, 1968) com B replicados.\nNo caso da tabela de contingência, a simulação é feita por amostragem aleatória do conjunto de todas as tabelas de contingência com marginais dados, e funciona apenas se as marginais forem estritamente positivas. A correção de continuidade nunca é usada, e a estatística é citada sem ela. Note que esta não é a situação usual de amostragem assumida para o teste qui-quadrado, mas sim para o teste exato de Fisher.<br/>\nNo caso da aderência, a simulação é feita por amostragem aleatória da distribuição discreta especificada por p, cada amostra tendo tamanho n = soma(x). Esta simulação é feita em R e pode ser lenta.<br/>\n<b>Valor</b></br>\nUma lista com a classe \"htest\" contendo os seguintes componentes:</br>\nstatistic: o valor da estatística do teste qui-quadrado.</br>\nparameter: os graus de liberdade da distribuição qui-quadrado aproximada da estatística do teste, NA se o valor p for computado por simulação de Monte Carlo.</br>\np.value: o valor p para o teste.</br>\nmethod: uma string de caracteres indicando o tipo de teste realizado, e se a simulação de Monte Carlo ou correção de continuidade foi usada.</br>\ndata.name: uma string de caracteres dando o(s) nome(s) dos dados.</br>\nobserved: as contagens observadas.</br>\nexpected: as contagens esperadas sob a hipótese nula.</br>\nresiduals: os resíduos de Pearson, (observado - esperado) / sqrt(esperado).</br>\nstdres: resíduos padronizados, (observado - esperado) / sqrt(V), onde V é a variância residual da célula (Agresti, 2007, seção 2.4.5 para o caso em que x é uma matriz, n * p * (1 - p) caso contrário).​​</br>\n<b>Exemplos</b><br/>\n<code> \n## De Agresti(2007) p.39\nM <- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))</br>\ndimnames(M) <- list(gender = c(\"F\", \"M\"),</br>\n                    party = c(\"Democrata\",\"Independente\", \"Republicano\"))</br>\n(Xsq <- chisq.test(M))  # Imprime resumo do teste</br>\nXsq$observed   # contagens observadas (mesmo que M)</br>\nXsq$expected   # contagens esperadas sob a nula</br>\nXsq$residuals  # resíduos de Pearson</br>\nXsq$stdres     # resíduos padronizados</br>\n</br>\n## Efeito de simular valores p</br>\nx <- matrix(c(12, 5, 7, 7), ncol = 2)</br>\nchisq.test(x)$p.value           # 0.4233</br>\nchisq.test(x, simulate.p.value = TRUE, B = 10000)$p.value</br>\n                                # cerca de 0.29!</br>\n</code> <br/>\n<b>Pacote</b></br>\nstats</br>\n<b>Ajuda</b></br>\nhelp(chisq.test, package ='caret')      \n"
  }
}