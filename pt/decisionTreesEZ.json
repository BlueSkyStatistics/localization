{
  "title": "Árvores de Decisão",
  "navigation": "Árvores de Decisão",
  "TxtTreeName": "Digite o nome do modelo",
  "TreeGenChkbox": "Não re-gerar se a árvore já existir",
  "dependent": "Variável dependente",
  "independent": "Variável(is) independente(s)",
  "weights": "Pesos da pesquisa",
  "TxtMinSplit": "Divisão mínima",
  "minBucket": "Balde mínimo",
  "TxtCP": "Parâmetro de complexidade",
  "maxDepth": "Profundidade máxima",
  "PruneTreeChkbox": "Poda da árvore",
  "rd0": "Não podar",
  "rd1": "Usar parâmetro de complexidade ótimo",
  "rd2": "Especificar parâmetro de complexidade",
  "TxtCPPrune": "Digite o parâmetro de complexidade",
  "PlotCVChkbox": "Plotar validação cruzada",
  "PlotRSQRChkbox": "Plotar R-quadrado",
  "OptvarPlots": "Gráficos",
  "OptvarPreprune": "Pré-poda",
  "OptvarPrune": "Poda da Árvore",
  "help": {
    "title": "Árvores de Decisão",
    "r_help": "help(rpart, package ='rpart')",
    "body": "\n                <b>Nota</b></br>\n                Variáveis dependentes podem ser fator, ordinal, string, lógico e numérico</br>\n                Variáveis independentes podem ser fator, ordinal, string, lógico e numérico</br></br>\n                <b>Descrição</b></br>\n                Ajusta um modelo de Árvore de Particionamento Recursivo e Regressão\n                <br/>\n                <b>Uso</b>\n                <br/>\n                <code> \n                rpart(formula, data, weights, subset, na.action = na.rpart, method,\n                      model = FALSE, x = FALSE, y = TRUE, parms, control, cost, ...)\n                </code> <br/>\n                <b>Argumentos</b><br/>\n                <ul>\n                <li>\n                formula: uma fórmula, com uma resposta mas sem termos de interação. Se isso for um data frame, isso é considerado como o modelo (veja model.frame).\n                </li>\n                <li>\n                data: um data frame opcional no qual interpretar as variáveis nomeadas na fórmula.\n                </li>\n                <li>\n                weights: pesos de caso opcionais.\n                </li>\n                <li>\n                subset: expressão opcional dizendo que apenas um subconjunto das linhas dos dados deve ser usado no ajuste.\n                </li>\n                <li>\n                na.action: a ação padrão exclui todas as observações para as quais y está faltando, mas mantém aquelas em que uma ou mais preditores estão faltando.\n                </li>\n                <li>\n                method: um dos \"anova\", \"poisson\", \"class\" ou \"exp\". Se o método estiver faltando, a rotina tenta fazer uma suposição inteligente. Se y for um objeto de sobrevivência, então method = \"exp\" é assumido, se y tiver 2 colunas, então method = \"poisson\" é assumido, se y for um fator, então method = \"class\" é assumido, caso contrário, method = \"anova\" é assumido. É mais sábio especificar o método diretamente, especialmente à medida que mais critérios podem ser adicionados à função no futuro.\n                Alternativamente, o método pode ser uma lista de funções chamadas init, split e eval. Exemplos são dados no arquivo 'tests/usersplits.R' nas fontes, e nos vignettes 'Funções de Divisão Escritas pelo Usuário'.\n                </li>\n                <li>\n                model: se lógico: manter uma cópia do modelo no resultado? Se o valor de entrada para o modelo for um modelo (provavelmente de uma chamada anterior à função rpart), então esse modelo é usado em vez de construir novos dados.\n                </li>\n                <li>\n                x: manter uma cópia da matriz x no resultado.\n                </li>\n                <li>\n                y: manter uma cópia da variável dependente no resultado. Se estiver faltando e o modelo for fornecido, isso padrão para FALSE.\n                </li>\n                <li>\n                parms: parâmetros opcionais para a função de divisão.<br/>\n                A divisão Anova não tem parâmetros.<br/>\n                A divisão Poisson tem um único parâmetro, o coeficiente de variação da distribuição anterior nas taxas. O valor padrão é 1.<br/>\n                A divisão Exponencial tem o mesmo parâmetro que Poisson.<br/>\n                Para a divisão de classificação, a lista pode conter qualquer um: o vetor de probabilidades anteriores (componente anterior), a matriz de perdas (componente perda) ou o índice de divisão (componente divisão). Os anteriores devem ser positivos e somar 1. A matriz de perdas deve ter zeros na diagonal e elementos positivos fora da diagonal. O índice de divisão pode ser gini ou informação. Os anteriores padrão são proporcionais às contagens de dados, as perdas padrão são 1, e a divisão padrão é gini.<br/>\n                </li>\n                <li>\n                control: uma lista de opções que controlam detalhes do algoritmo rpart. Veja rpart.control.\n                </li>\n                <li>\n                cost: um vetor de custos não negativos, um para cada variável no modelo. Padrão para um para todas as variáveis. Estes são escalonamentos a serem aplicados ao considerar divisões, então a melhoria na divisão em uma variável é dividida pelo seu custo ao decidir qual divisão escolher.\n                </li>\n                <li>\n                ...: argumentos para rpart.control também podem ser especificados na chamada para rpart. Eles são verificados contra a lista de argumentos válidos.\n                </li>\n                </ul>\n                <b>Detalhes</b></br>\n                Isso difere da função tree em S principalmente em seu tratamento de variáveis substitutas. Em muitos detalhes, segue Breiman et. al (1984) de perto. O pacote R tree fornece uma reimplementação da árvore.\n                <b>Valor</b></br>\n                Um objeto da classe rpart. Veja rpart.object.</br>\n                <b>Referências</b></br>\n                Breiman L., Friedman J. H., Olshen R. A., e Stone, C. J. (1984) Árvores de Classificação e Regressão. Wadsworth.</br>\n                <b>Veja Também</b></br>\n                rpart.control, rpart.object, summary.rpart, print.rpart</br>\n                <b>Exemplos</b></br>\n                fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)</br>\n                fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              parms = list(prior = c(.65,.35), split = \"information\"))</br>\n                fit3 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis,\n                              control = rpart.control(cp = 0.05))</br>\n                par(mfrow = c(1,2), xpd = NA) # caso contrário, em alguns dispositivos o texto é cortado</br>\n                plot(fit)</br>\n                text(fit, use.n = TRUE)</br>\n                plot(fit2)</br>\n                text(fit2, use.n = TRUE)</br>\n                <b>Pacote</b></br>\n                rpart;rpart.plot;partykit</br>\n                <b>Ajuda</b></br>\n                help(rpart, package ='rpart')</br></br>\n                <b>Descrição</b></br>\n                Controle para Ajustes Rpart. Vários parâmetros que controlam aspectos do ajuste rpart.\n                <br/>\n                <b>Uso</b>\n                <br/>\n                <code> \n                rpart.control(minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, \n                              maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10,\n                              surrogatestyle = 0, maxdepth = 30, ...)\n                </code> <br/>\n                <b>Argumentos</b><br/>\n                <ul>\n                <li>\n                minsplit: o número mínimo de observações que devem existir em um nó para que uma divisão seja tentada.\n                </li>\n                <li>\n                minbucket: o número mínimo de observações em qualquer nó terminal <leaf>. Se apenas um dos minbucket ou minsplit for especificado, o código define minsplit para minbucket*3 ou minbucket para minsplit/3, conforme apropriado.\n                </li>\n                <li>\n                cp: parâmetro de complexidade. Qualquer divisão que não diminua a falta de ajuste geral por um fator de cp não é tentada. Por exemplo, com a divisão anova, isso significa que o R-quadrado geral deve aumentar em cp a cada passo. O papel principal deste parâmetro é economizar tempo de computação podando divisões que não são obviamente valiosas. Essencialmente, o usuário informa ao programa que qualquer divisão que não melhore o ajuste em cp provavelmente será podada pela validação cruzada, e que, portanto, o programa não precisa persegui-la.\n                </li>\n                <li>\n                maxcompete: o número de divisões concorrentes retidas na saída. É útil saber não apenas qual divisão foi escolhida, mas qual variável ficou em segundo, terceiro, etc.\n                </li>\n                <li>\n                maxsurrogate: o número de divisões substitutas retidas na saída. Se isso for definido como zero, o tempo de computação será reduzido, uma vez que aproximadamente metade do tempo de computação (além da configuração) é usado na busca por divisões substitutas.\n                </li>\n                <li>\n                usesurrogate: como usar substitutos no processo de divisão. 0 significa exibir apenas; uma observação com um valor ausente para a regra de divisão primária não é enviada mais adiante na árvore. 1 significa usar substitutos, na ordem, para dividir sujeitos que faltam a variável primária; se todos os substitutos estiverem ausentes, a observação não é dividida. Para o valor 2, se todos os substitutos estiverem ausentes, então envie a observação na direção da maioria. Um valor de 0 corresponde à ação da árvore, e 2 às recomendações de Breiman et.al (1984).\n                </li>\n                <li>\n                xval: número de validações cruzadas.\n                </li>\n                <li>\n                surrogatestyle: controla a seleção de um melhor substituto. Se definido como 0 (padrão), o programa usa o número total de classificações corretas para uma variável substituta potencial, se definido como 1, usa a porcentagem correta, calculada sobre os valores não ausentes do substituto. A primeira opção penaliza mais severamente covariáveis com um grande número de valores ausentes.\n                </li>\n                <li>\n                maxdepth: Define a profundidade máxima de qualquer nó da árvore final, com o nó raiz contado como profundidade 0. Valores superiores a 30 rpart darão resultados sem sentido em máquinas de 32 bits.\n                </li>\n                <li>\n                ...: limpar outros argumentos.\n                </li>\n                </ul>\n                <b>Valor</b></br>\n                Uma lista contendo as opções. \n                      "
  }
}