{
  "title": "Regressão Ordinal",
  "navigation": "Ordinal",
  "label1": "Método de teste",
  "logit": "Logit",
  "probit": "Probit",
  "modelname": "Insira o nome do modelo",
  "dependent": "Variável dependente",
  "formula": "Variável(is) independente(s)",
  "generateplotchk": "Plotar resíduos vs ajustados, Q-Q normal, escala-local e resíduos vs alavancagem",
  "weights": "Especifique uma variável com pesos",
  "help": {
    "title": "Ordinal",
    "r_help": "help(polr, package=MASS)",
    "body": "\n            <b>Descrição</b></br>\n            Ajusta um modelo de regressão logística ou probit a uma resposta de fator ordenado. O caso logístico padrão é a regressão logística de odds proporcionais, após o qual a função é nomeada.\n            <br/>\n            <b>Uso</b>\n            <br/>\n            <code> \n            polr(formula, data, weights, start, ..., subset, na.action,\n                 contrasts = NULL, Hess = FALSE, model = TRUE,\n                 method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))\n            </code> <br/>\n            <b>Argumentos</b><br/>\n            <ul>\n            <li>\n            formula: uma expressão de fórmula como para modelos de regressão, da forma resposta ~ preditores. A resposta deve ser um fator (preferencialmente um fator ordenado), que será interpretado como uma resposta ordinal, com níveis ordenados como no fator. O modelo deve ter um intercepto: tentativas de removê-lo levarão a um aviso e serão ignoradas. Um offset pode ser usado. Consulte a documentação da fórmula para outros detalhes.\n            </li>\n            <li>\n            data: um data frame opcional no qual interpretar as variáveis que ocorrem na fórmula.\n            </li>\n            <li>\n            weights: pesos de caso opcionais na adequação. Padrão para 1.\n            </li>\n            <li>\n            start: valores iniciais para os parâmetros. Isso está no formato c(coeficientes, zeta): veja a seção Valores.\n            </li>\n            <li>\n            ... argumentos adicionais a serem passados para optim, mais frequentemente um argumento de controle.\n            </li>\n            <li>\n            subset: expressão dizendo qual subconjunto das linhas dos dados deve ser usado na adequação. Todas as observações são incluídas por padrão.\n            </li>\n            <li>\n            na.action: uma função para filtrar dados ausentes.\n            </li>\n            <li>\n            contrasts: uma lista de contrastes a serem usados para alguns ou todos os fatores que aparecem como variáveis na fórmula do modelo.\n            </li>\n            <li>\n            Hess: lógico para se a Hessiana (a matriz de informação observada) deve ser retornada. Use isso se você pretende chamar resumo ou vcov na adequação.\n            </li>\n            <li>\n            model: lógico para se a matriz do modelo deve ser retornada.\n            </li>\n            <li>\n            method: logístico ou probit ou (complementar) log-log ou cauchit (correspondente a uma variável latente de Cauchy).\n            </li>\n            </ul>\n            <b>Detalhes</b></br>\n            Este modelo é o que Agresti (2002) chama de modelo de link cumulativo. A interpretação básica é como uma versão coarsened de uma variável latente Y_i que tem uma distribuição logística ou normal ou de valor extremo ou de Cauchy com parâmetro de escala um e um modelo linear para a média. O fator ordenado que é observado é em qual bin Y_i cai com pontos de quebra\n            zeta_0 = -Inf < zeta_1 < … < zeta_K = Inf</br>\n            Isso leva ao modelo</br>\n            logit P(Y <= k | x) = zeta_k - eta</br>\n            com logit substituído por probit para uma variável latente normal, e eta sendo o preditor linear, uma função linear das variáveis explicativas (sem intercepto). Note que é bastante comum que outros softwares usem o sinal oposto para eta (e, portanto, os coeficientes beta).</br>\n            No caso logístico, o lado esquerdo da última exibição é as odds logarítmicas da categoria k ou menos, e uma vez que essas são odds logarítmicas que diferem apenas por uma constante para diferentes k, as odds são proporcionais. Daí o termo regressão logística de odds proporcionais.</br>\n            Os links log-log e log-log complementar são as funções crescentes F^-1(p) = -log(-log(p)) e F^-1(p) = log(-log(1-p)); alguns chamam o primeiro de link 'log-log negativo'. Estes correspondem a uma variável latente com a distribuição de valor extremo para o máximo e mínimo, respectivamente.</br>\n            Um modelo de riscos proporcionais para tempos de sobrevivência agrupados pode ser obtido usando o link log-log complementar com agrupamento ordenado por tempos crescentes.</br>\n            predict, resumo, vcov, anova, model.frame e um método extractAIC para uso com stepAIC (e step). Também existem métodos de perfil e confint.</br>\n            <b>Valor</b><br/>\n            Um objeto da classe \"polr\". Isso tem componentes\n            <li>\n            coeficientes: os coeficientes do preditor linear, que não tem intercepto.\n            </li>\n            <li>\n            zeta: os interceptos para os limites de classe.\n            </li>\n            <li>\n            deviance: a deviance residual.\n            </li>\n            <li>\n            fitted.values: uma matriz, com uma coluna para cada nível da resposta.\n            </li>\n            <li>\n            lev: os nomes dos níveis de resposta.\n            </li>\n            <li>\n            termos: a estrutura de termos descrevendo o modelo.\n            </li>\n            <li>\n            df.residual: o número de graus de liberdade residuais, calculado usando os pesos.\n            </li>\n            <li>\n            edf: o número (efetivo) de graus de liberdade usados pelo modelo\n            </li>\n            <li>\n            n, nobs: o número (efetivo) de observações, calculado usando os pesos. (nobs é para uso pelo stepAIC.\n            </li>\n            <li>\n            chamada: a chamada correspondente.\n            </li>\n            <li>\n            método: o método correspondente usado.\n            </li>\n            <li>\n            convergência: o código de convergência retornado por optim.\n            </li>\n            <li>\n            niter: o número de avaliações de função e gradiente usadas por optim.\n            </li>\n            <li>\n            lp: o preditor linear (incluindo qualquer offset).</li>\n            <li>\n            Hessiana: (se Hess for verdadeiro). Note que isso é uma aproximação numérica derivada do processo de otimização.\n            </li>\n            <li>\n            modelo:(se o modelo for verdadeiro).\n            </li>\n            <li>\n            Nota</br>\n            O método vcov usa a Hessiana aproximada: para resultados confiáveis, a matriz do modelo deve ser escalada de forma sensata, com todas as colunas tendo uma faixa da ordem de um.</br>\n            Antes da versão 7.3-32, o método = \"cloglog\" confusamente dava o link log-log, assumindo implicitamente que o primeiro nível de resposta era o 'melhor'.</br>\n            <br/>\n            <b>Exemplos</b><br/>\n            <code> \n            options(contrasts = c(\"contr.treatment\", \"contr.poly\"))<br/>\n            house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)<br/>\n            house.plr<br/>\n            summary(house.plr, digits = 3)<br/>\n            ## ajuste ligeiramente pior de<br/>\n            summary(update(house.plr, method = \"probit\", Hess = TRUE), digits = 3)<br/>\n            ## embora não seja realmente apropriado, pode ajustar<br/>\n            summary(update(house.plr, method = \"loglog\", Hess = TRUE), digits = 3)<br/>\n            summary(update(house.plr, method = \"cloglog\", Hess = TRUE), digits = 3)<br/>\n            <br/>\n            predict(house.plr, housing, type = \"p\")<br/>\n            addterm(house.plr, ~.^2, test = \"Chisq\")<br/>\n            house.plr2 <- stepAIC(house.plr, ~.^2)<br/>\n            house.plr2$anova<br/>\n            anova(house.plr, house.plr2)<br/>\n            <br/>\n            house.plr <- update(house.plr, Hess=TRUE)<br/>\n            pr <- profile(house.plr)<br/>\n            confint(pr)<br/>\n            plot(pr)<br/>\n            pairs(pr)<br/>\n            </code> <br/>\n            <b>Pacote</b></br>\n            MASS</br>\n            <b>Ajuda</b></br>\n            Para ajuda detalhada, clique no ícone R no canto superior direito deste diálogo ou execute o seguinte comando help(polr, package =MASS) criando um bloco de código R clicando + na janela de saída\t\t\t"
  }
}